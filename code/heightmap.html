<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>namecode: Sentiers</title>
        <style>
            html, body {
                width: 100%;
                height: 100%;
            }

            body {
                background-color: #ffffff;
                margin: 0;
                overflow: hidden;
                font-family: Liberation Mono;
            }
			
			#canvas { display: none; }
			#assets { display: none; }
			
            #blocker {

                position: absolute;

                width: 100%;
                height: 100%;

                background-color: rgba(0,0,0,0.5);

            }

            #instructions {

                width: 100%;
                height: 100%;

                display: -webkit-box;
                display: -moz-box;
                display: box;

                -webkit-box-orient: horizontal;
                -moz-box-orient: horizontal;
                box-orient: horizontal;

                -webkit-box-pack: center;
                -moz-box-pack: center;
                box-pack: center;

                -webkit-box-align: center;
                -moz-box-align: center;
                box-align: center;

                color: #ffffff;
                text-align: center;
				height: 500px;

                cursor: pointer;

            }

        </style>
    </head>
    <body>
	
	    <div id="assets"><img id="landscape-image" src="../assets/images/Heightmap.png"/></div>
		<canvas id="canvas"></canvas>
        <script src="../libs/three84.js"></script>
		<script src="../libs/OrbitControls.js"></script>
		<script src="../libs/cannon.js"></script>
		<script src="../libs/cannon.demo.js"></script>
		

        <script>


            var camera, scene, renderer;
			
			var ambientLight, spotLight;
			var imgLoader;
			
			var world;
			var l;
			var sizeX, sizeY;
			var terrain;
			var terrain2;
			
			initCannon();
            init();
            animate();


			
		//To get the pixels, draw the image onto a canvas. From the canvas get the Pixel (R,G,B,A)
function getTerrainPixelData()
{
  var img = document.getElementById("landscape-image");
  var canvas = document.getElementById("canvas");
  
  canvas.width = img.width;
  canvas.height = img.height;
  canvas.getContext('2d').drawImage(img, 0, 0, img.width, img.height);

  var data = canvas.getContext('2d').getImageData(0,0, img.height, img.width).data;
  var normPixels = []

  for (var i = 0, n = data.length; i < n; i += 4) {
    // get the average value of R, G and B.
    normPixels.push((data[i] + data[i+1] + data[i+2]) / 3);
  }
	console.log(normPixels);
  return normPixels;
}

	//terrain = getTerrainPixelData();
			
	function initCannon(){
		
		terrain = getTerrainPixelData();
		
		world = new CANNON.World();
		world.quatNormalizeSkip = 0;
        world.quatNormalizeFast = false;

		var solver = new CANNON.GSSolver();
		
		world.defaultContactMaterial.contactEquationStiffness = 1e9;
		world.defaultContactMaterial.contactEquationRelaxation = 4;
		
        solver.iterations = 7;
        solver.tolerance = 0.1;
        var split = true;
        if(split)
            world.solver = new CANNON.SplitSolver(solver);
        else
            world.solver = solver;

        world.gravity.set(0,-100,0);
        world.broadphase = new CANNON.NaiveBroadphase();

        // Create a slippery material (friction coefficient = 0.0)
        physicsMaterial = new CANNON.Material("slipperyMaterial");
        var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
                                                                physicsMaterial,
                                                                0.0, // friction coefficient
                                                                0.3  // restitution
                                                                );
                // We must add the contact materials to the world
        world.addContactMaterial(physicsContactMaterial);
		
		
		
		sizeX = 2400;
		sizeY = 2400;
		for (var i = 0; i < sizeX; i++) {
		//	terrain.push([]);
			//for (var j = 0; j < sizeY; j++) {
				//var height = Math.cos(i/sizeX * Math.PI * 2)*Math.cos(j/sizeY * Math.PI * 2) + 2;
				//if(i===0 || i===sizeX-1 || j=== sizeY-1){
				//height = 3;
			}
			
		//console.log(terrain + "in cannon");	
		 // Create the heightfield shape
        var heightfieldShape = new CANNON.Heightfield(terrain, {
            elementSize: 1 // Distance between the data points in X and Y directions
        });
        var heightfieldBody = new CANNON.Body();
        heightfieldBody.addShape(heightfieldShape);
        world.addBody(heightfieldBody);
		demo.addVisual(heightfieldBody);
			
		/*	
		// Create the heightfield
        var hfShape = new CANNON.Heightfield(terrain, {
            elementSize: 1
        });
        var hfBody = new CANNON.Body({ mass: 0 });
        hfBody.addShape(hfShape);
        //hfBody.position.set(-sizeX * hfShape.elementSize / 2, -20, -10);
        world.addBody(hfBody);
		*/
		
	}
	
	
		
 	
	
			
    function init() {
				
		///// L O A D I N G   M A N A G E R /////
		loadingManager = new THREE.LoadingManager();
		textureLoader = new THREE.TextureLoader(loadingManager);
	
		loadingManager.onLoad = function ( ) {
			loadingComplete = true;
			console.log( 'Loading complete!');
		};
		
		imgLoader = new THREE.ImageLoader();
		
		var heightmap = imgLoader.load('../assets/images/Heightmap.png');
				
		container = document.createElement( 'div' );
		document.body.appendChild( container );

        scene = new THREE.Scene();
		
		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 10000 );
		camera.position.set(0, 240, 1000);
		camera.lookAt(scene.position);
		
						// OrbitControls
				controls = new THREE.OrbitControls( camera, renderer );
				controls.addEventListener( 'change', render ); 
		
		var cube = new THREE.Mesh(new THREE.BoxGeometry(10,10,10), new THREE.MeshLambertMaterial({color: 0x0000ff}));
		//scene.add(cube);

		ambientLight = new THREE.AmbientLight(0xffffff, .5);
		scene.add(ambientLight);
			
		var sunPositionX = 0;
		var sunPositionY = 500;
		var sunPositionZ = 825;	
			
        light = new THREE.DirectionalLight( 0xFEFFF3, .55   );
        light.position.set( sunPositionX, sunPositionY, sunPositionZ );
		scene.add( light );
		
		spotLight = new THREE.SpotLight( 0xffcccc, 1.27);
        spotLight.position.set(175 , 30, 787.5 );
		spotLight.target.position.set(70, 40, 787.5);
		scene.add(spotLight.target);
       // scene.add(spotLight);
	   
        renderer = new THREE.WebGLRenderer(/*{antialias: true}*/);
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setClearColor( 0xE9F6F6, 1 );
		
	
		
		var numSegments = 100;

		var geometry = new THREE.PlaneGeometry(sizeX, sizeY, numSegments, numSegments);
		var material = new THREE.MeshLambertMaterial({
			color: 0xccccff,
			wireframe: false
		});

  //terrain = getTerrainPixelData();  

	//console.log(getTerrainPixelData());
	console.log(terrain);
  // keep in mind, that the plane has more vertices than segments. If there's one segment, there's two vertices, if
  // there's 10 segments, there's 11 vertices, and so forth. 
  // The simplest is, if like here you have 100 segments, the image to have 101 pixels. You don't have to worry about
  // "skewing the landscape" then..

  // to check uncomment the next line, numbers should be equal
   console.log("length: " + terrain.length + ", vertices length: " + geometry.vertices.length);

   l = geometry.vertices.length;
   
  for (var i = 0; i < l; i++)
  {
    var terrainValue = terrain[i] / 255;
    geometry.vertices[i].z = geometry.vertices[i].z + terrainValue * 100 ;
  }

  geometry.computeFaceNormals();
  geometry.computeVertexNormals();

  var plane = new THREE.Mesh(geometry, material);

  plane.position = new THREE.Vector3(0,0,0);
  // rotate the plane so up is where y is growing..

  var q = new THREE.Quaternion();
  q.setFromAxisAngle( new THREE.Vector3(-1,0,0), 90 * Math.PI / 180 );
  plane.quaternion.multiplyQuaternions( q, plane.quaternion );

  //scene.add(plane)

		
						
        document.body.appendChild( renderer.domElement );

		var size = 240;
		var divisions = 10;
		var gridHelper = new THREE.GridHelper( 1000, 100 );
		//scene.add( gridHelper );
		
		axisHelper = new THREE.AxisHelper( 50 );
		//scene.add( axisHelper );
    }
	


			
			
	function animate(){				
		setTimeout( function() {
		requestAnimationFrame( animate );
		}, 1000 / 60 );
		render();
	}
			
    function render() {
	
		renderer.render( scene, camera );
    }
        </script>
    </body>
</html>