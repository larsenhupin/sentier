<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>namecode: Sentiers</title>
        <style>
            html, body {
                width: 100%;
                height: 100%;
            }

            body {
                background-color: #ffffff;
                margin: 0;
                overflow: hidden;
                font-family: Liberation Mono;
            }

            #blocker {

                position: absolute;

                width: 100%;
                height: 100%;

                background-color: rgba(0,0,0,0.5);

            }

            #instructions {

                width: 100%;
                height: 100%;

                display: -webkit-box;
                display: -moz-box;
                display: box;

                -webkit-box-orient: horizontal;
                -moz-box-orient: horizontal;
                box-orient: horizontal;

                -webkit-box-pack: center;
                -moz-box-pack: center;
                box-pack: center;

                -webkit-box-align: center;
                -moz-box-align: center;
                box-align: center;

                color: #ffffff;
                text-align: center;
				height: 500px;

                cursor: pointer;

            }

        </style>
    </head>
    <body>
        <script src="../libs/three84.js"></script>
        <script src="../build/cannon.js"></script>
        <script src="../libs/PointerLockControls.js"></script>
		<script src="../libs/Tween.js"></script>


        <div id="blocker">

            <div id="instructions">
                <span style="font-size:70px">namecode: Sentiers</span>
                <br />
            </div>

			<div id="WebGL-output">
			</div>
			
			
        </div>

        <script>

            var blocker = document.getElementById( 'blocker' );
            var instructions = document.getElementById( 'instructions' );

            var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

            if ( havePointerLock ) {

                var element = document.body;

                var pointerlockchange = function ( event ) {

                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
					
						controlsEnabled = true;
                        controls.enabled = true;
						

                        blocker.style.display = 'none';

                    } else {

                        controls.enabled = false;

                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';

                        instructions.style.display = '';

                    }

                }

                var pointerlockerror = function ( event ) {
                    instructions.style.display = '';
                }

                
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

                instructions.addEventListener( 'click', function ( event ) {
                    instructions.style.display = 'none';
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
					
                    if ( /Firefox/i.test( navigator.userAgent ) ) {

                        var fullscreenchange = function ( event ) {

                            if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

                                document.removeEventListener( 'fullscreenchange', fullscreenchange );
                                document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

                                element.requestPointerLock();
                            }
                        }
						
                        document.addEventListener( 'fullscreenchange', fullscreenchange, false );
                        document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

                        element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
                        element.requestFullscreen();	
                    }
					else {
                        element.requestPointerLock();
					}
                }, false);
            } else {
                instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
            }

			THREE.Sphere.__closest = new THREE.Vector3();
			THREE.Sphere.prototype.intersectsBox = function (box) {
			// get box closest point to sphere center by clamping
			THREE.Sphere.__closest.set(this.center.x, this.center.y, this.center.z);
			THREE.Sphere.__closest.clamp(box.min, box.max);

			var distance =  this.center.distanceToSquared(THREE.Sphere.__closest);
			return distance < (this.radius * this.radius);
			};
			
			var sphereShape, sphereBody, world, physicsMaterial, walls=[], balls=[], ballMeshes=[], boxes=[], boxMeshes=[];

            var camera, scene, renderer;
			
			var ambientLight;
			
			
			// ** Audio ** //
			var listener, sound, audioLoader, play;
			
            var geometry, material, mesh;
			var controlsEnabled = false;
            var controls, time = Date.now();
			var objects = [];
			var action = {}, action2 = {};
			var mixer, mixer2;
			var clock, delta2;
			
			var object01 = [], object02 = [],
				object03 = [];
				
			var count01 = 1, count02 = 1,
				count03 = 1;
			
			var jsonLoader;
			var enveloppe;
			var feuille;
			
			var loadingManager;
			var loadingComplete;
			
			var radius = 3.5;
			
			var collisionDetected02, collisionDetected03;
			
			var trigger00, trigger00Body;
			var cubeBBox;
			var sphereBBox;
			
			var trigger02, trigger03, AABBtrigger02, AABBtrigger03;
			
			var mesh01;
			
            initCannon();
            init();
            animate();

            function initCannon(){
                // Setup our world
                world = new CANNON.World();
                world.quatNormalizeSkip = 0;
                world.quatNormalizeFast = false;

                var solver = new CANNON.GSSolver();

                world.defaultContactMaterial.contactEquationStiffness = 1e9;
                world.defaultContactMaterial.contactEquationRelaxation = 4;

                solver.iterations = 7;
                solver.tolerance = 0.1;
                var split = true;
                if(split)
                    world.solver = new CANNON.SplitSolver(solver);
                else
                    world.solver = solver;

                world.gravity.set(0,-30,0);
                world.broadphase = new CANNON.NaiveBroadphase();

                // Create a slippery material (friction coefficient = 0.0)
                physicsMaterial = new CANNON.Material("slipperyMaterial");
                var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
                                                                        physicsMaterial,
                                                                        0.0, // friction coefficient
                                                                        0.3  // restitution
                                                                        );
                // We must add the contact materials to the world
                world.addContactMaterial(physicsContactMaterial);

                // Create a sphere
                var mass = 100;
                sphereShape = new CANNON.Sphere(radius);
                sphereBody = new CANNON.Body({ mass: mass });
                sphereBody.addShape(sphereShape);
                sphereBody.position.set(0,5,-120);
				//sphereBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI);
                sphereBody.linearDamping = 0.9;
                world.addBody(sphereBody);

                // Create a plane
                var groundShape = new CANNON.Plane();
                var groundBody = new CANNON.Body({ mass: 0 });
				
                groundBody.addShape(groundShape);
				groundBody.position.set(0,0,0);
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
                world.addBody(groundBody);
            }

    function init() {
				
		///// L O A D I N G   M A N A G E R /////
		loadingManager = new THREE.LoadingManager();
		textureLoader = new THREE.TextureLoader(loadingManager);
	
		loadingManager.onLoad = function ( ) {
			loadingComplete = true;
			console.log( 'Loading complete!');
		};
				
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 1000 );
				
		container = document.createElement( 'div' );
		document.body.appendChild( container );

        scene = new THREE.Scene();
        scene.fog = new THREE.Fog( 0xffffff, 0, 500 );

		ambientLight = new THREE.AmbientLight(0xffffff, .5);
		scene.add(ambientLight);
			
        light = new THREE.SpotLight( 0xffffff );
        light.position.set( 10, 30, 20 );
        light.target.position.set( 0, 0, 0 );
        if(true){
            //light.castShadow = true;
			/*
            light.shadowCameraNear = 20;
            light.shadowCameraFar = 50;//camera.far;
            light.shadowCameraFov = 40;
            light.shadowMapBias = 0.1;
            light.shadowMapDarkness = 0.7;
            light.shadowMapWidth = 2*512;
            light.shadowMapHeight = 2*512;
			*/	
            //light.shadowCameraVisible = true;
        }
		scene.add( light );
		
		//scene.updateMatrixWorld(true);
		
		listener = new THREE.AudioListener();
		camera.add(listener);	
		sound = new THREE.Audio(listener);
		audioLoader = new THREE.AudioLoader();
		
	//Load a sound and set it as the Audio object's buffer
		audioLoader.load( '../assets/The_Monolith_On_The_Moon.ogg', function( buffer ) {
			sound.setBuffer( buffer );
			sound.setLoop(true);
			sound.setVolume(.7);
			//sound.play();
		});	

		var spherePlayerGeometry = new THREE.SphereGeometry(radius);
		var spherePlayerMaterial = new THREE.MeshBasicMaterial({ color: 0x0000FF, 
															 	 side: THREE.DoubleSide, 
																 wireframe: true,
																 transparent: true, 
																 opacity: .5 });
		
		var player		 = new THREE.Mesh(spherePlayerGeometry, spherePlayerMaterial);
		player.geometry.computeBoundingSphere();
		
		sphereBBox = new THREE.Sphere(player.position,
								player.geometry.boundingSphere.radius);
		//scene.add(player);
		//player.position.set(0,5,-120)
		
		
		
		var wandGeometry 	= new THREE.BoxGeometry(.1, 2, .1);
		var wandMaterial	= new THREE.MeshLambertMaterial({color: 0xffffff });
		var wand			= new THREE.Mesh(wandGeometry, wandMaterial);
		camera.add(wand);
		wand.position.set(1, -1.5, -3);
		wand.rotation.x = -.15 * Math.PI;
		wand.rotation.z = .09 * Math.PI;

        material = new THREE.MeshLambertMaterial( { color: 0xdddddd } );
               		

        renderer = new THREE.WebGLRenderer(/*{antialias: true}*/);
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setClearColor( 0xE9F6F6, 1 );
		
		var floorGeometry = new THREE.PlaneGeometry(600, 600, 1, 1);
        var floorMaterial = new THREE.MeshLambertMaterial({	color: 0xE0FFD4,
															emissive: 0xffffff,
															emissiveIntensity: 0.5
															});
		
        var floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.receiveShadow = true;
		scene.add(floor);
		floor.position.y = -.3;
		floor.rotation.x = -0.5 * Math.PI;

		controls = new PointerLockControls( camera ,sphereBody, player);
        scene.add( controls.getObject() );		
		controls.getObject().position.z = -120;
		controls.getObject().rotation.y = .5 * Math.PI;
		
				
        document.body.appendChild( renderer.domElement );
        window.addEventListener( 'resize', onWindowResize, false );

		
		var halfExtents1 = new CANNON.Vec3(.1,20,60);
		var wall00Shape = new CANNON.Box(halfExtents1);
		var wall00Body = new CANNON.Body({ mass: 0 });
		wall00Body.addShape(wall00Shape);
		world.addBody(wall00Body);
		wall00Body.position.set(60,0,-120);		
		
		var wallGeometry = new THREE.PlaneGeometry(120, 120, 1, 1);
        var wallMaterial = new THREE.MeshLambertMaterial({color: 0x19FCBC, side: THREE.DoubleSide });
        var wall = new THREE.Mesh(wallGeometry, wallMaterial);
        scene.add(wall);
		wall.rotation.y = -0.5 * Math.PI;
		wall.position.set(60, 0, -120);
		
		var roofGeometry = new THREE.PlaneGeometry(120, 120, 1, 1);
        var roofMaterial = new THREE.MeshLambertMaterial({color: 0x19FCBC });
        var roof = new THREE.Mesh(roofGeometry, roofMaterial);
        scene.add(roof);
		roof.rotation.x = 0.5 * Math.PI;
		roof.position.set(0, 60, -120);
		
		var halfExtentsTrigger00 = new CANNON.Vec3(15,2,15);
		var trigger00Shape = new CANNON.Box(halfExtentsTrigger00);
			trigger00Body = new CANNON.Body({ mass: 0 });
		trigger00Body.addShape(trigger00Shape);
		world.addBody(trigger00Body);
		
		
		
		trigger00Body.position.set(-90,0,-120);		
		
		var trigger00Geometry = new THREE.BoxGeometry(30, 4, 30, 6, 6, 6);
		var trigger00Material = new THREE.MeshLambertMaterial({color: 0xFF00FF, transparent: true, opacity: 1});
			trigger00 		  = new THREE.Mesh(trigger00Geometry, trigger00Material);
		cubeBBox = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
		scene.add(trigger00);
		trigger00.position.set(-90, 0, -120);
		
		var trigger02Geometry = new THREE.BoxGeometry( 6, 30, 4, 1, 1 ); 
		var trigger02Material = new THREE.MeshLambertMaterial({color: 0xFF00FF, transparent: true, opacity: 0.2});
			trigger02 		  =	new THREE.Mesh(trigger02Geometry, trigger02Material);
			AABBtrigger02 	  = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
		scene.add(trigger02);
		trigger02.position.set(120, 0, -60);
		
		var trigger03Geometry = new THREE.BoxGeometry( 40, 30, 4, 1, 1 );
		var trigger03Material = new THREE.MeshLambertMaterial({color: 0xFF00FF, transparent: true, opacity: 0.2});
			trigger03 		  =	new THREE.Mesh(trigger03Geometry, trigger03Material);
			AABBtrigger03 	  = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
		scene.add(trigger03);
		trigger03.position.set(120, 0, -135);
		

	
		//SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)
		var greatSphereGeometry = new THREE.SphereGeometry(60, 24, 24, 0);
		var greatSphereMaterial = new THREE.MeshBasicMaterial({color: 0x0000FF, side: THREE.DoubleSide});
		greatSphere 			= new THREE.Mesh(greatSphereGeometry, greatSphereMaterial);
		scene.add(greatSphere);
		greatSphere.position.set(120, 30, -120);
	
		var greatSphereGeometry = new THREE.SphereGeometry(60, 24, 24, 0);
		var greatSphereMaterial = new THREE.MeshBasicMaterial({color: 0x00000f, side: THREE.DoubleSide, wireframe: true});
		var greatSphere 		= new THREE.Mesh(greatSphereGeometry, greatSphereMaterial);
		scene.add(greatSphere);
		greatSphere.position.set(120, 30, -120);
		
		var halfExtents00 = new CANNON.Vec3(60,30,60);
		var mesh00Shape = new CANNON.Box(halfExtents00);
		var mesh00Body = new CANNON.Body({ mass: 0 });
		mesh00Body.addShape(mesh00Shape);
		world.addBody(mesh00Body);
		mesh00Body.position.set(0,15,0);
		
		var mesh00Geometry 	= new THREE.BoxGeometry(120, 120, 120, 1, 1, 1);
		var mesh00Material 	= new THREE.MeshLambertMaterial({color: 0x19FCBC});
		mesh00			= new THREE.Mesh(mesh00Geometry, mesh00Material);
		scene.add(mesh00);
		//collidableMeshList.push(mesh00);
		mesh00.position.set(0, 0, 0);
		
		var mesh01Geometry 	= new THREE.SphereGeometry(90, 32, 32, 0);
		var mesh01Material 	= new THREE.MeshBasicMaterial({wireframe: true, color: 0xFF0000});
		mesh01			= new THREE.Mesh(mesh01Geometry, mesh01Material);
		scene.add(mesh01);
		mesh01.position.set(-240, 30, -240);
		
		var halfExtents = new CANNON.Vec3(60,30,60);
		var mesh02Shape = new CANNON.Box(halfExtents);
		var mesh02Body = new CANNON.Body({ mass: 0 });
		mesh02Body.addShape(mesh02Shape);
		world.addBody(mesh02Body);
		mesh00Body.position.set(0,15,-240);
				
		var mesh02Geometry 	= new THREE.BoxGeometry(120, 60, 120);
		var mesh02Material 	= new THREE.MeshLambertMaterial({color: 0x19FCBC});
		var mesh02			= new THREE.Mesh(mesh02Geometry, mesh02Material);
		scene.add(mesh02);
		mesh02.position.set(0, 30, -240);
		
		
		//** Wall2 = mesh03 **//
		var mesh03Geometry 	= new THREE.PlaneGeometry(240, 120, 1, 1);
		var mesh03Material 	= new THREE.MeshLambertMaterial({color: 0x19FCBC});
		var mesh03			= new THREE.Mesh(mesh03Geometry, mesh03Material);
		scene.add(mesh03);
		mesh03.position.set(180, 0, -180);
		mesh03.rotation.y = -.5 * Math.PI;
		
		var mesh04Geometry 	= new THREE.BoxGeometry(120, 120, 120);
		var mesh04Material 	= new THREE.MeshLambertMaterial({color: 0x19FCBC});
		var mesh04			= new THREE.Mesh(mesh04Geometry, mesh04Material);
		scene.add(mesh04);
		mesh04.position.set(240, 0, 0);
		
		var mesh05Geometry 	= new THREE.BoxGeometry(120, 120, 120);
		var mesh05Material 	= new THREE.MeshLambertMaterial({color: 0x000000});
		var mesh05			= new THREE.Mesh(mesh05Geometry, mesh05Material);
		scene.add(mesh05);
		mesh05.position.set(240, 0, 240);
		
		var mesh06Geometry 	= new THREE.BoxGeometry(120, 120, 120);
		var mesh06Material 	= new THREE.MeshLambertMaterial({color: 0x000000});
		var mesh06			= new THREE.Mesh(mesh06Geometry, mesh06Material);
		scene.add(mesh06);
		mesh06.position.set(0, 0, 240);
		
		var mesh07Geometry 	= new THREE.BoxGeometry(120, 120, 120);
		var mesh07Material 	= new THREE.MeshLambertMaterial({color: 0x00ff00});
		var mesh07			= new THREE.Mesh(mesh07Geometry, mesh07Material);
		scene.add(mesh07);
		mesh07.position.set(-240, 0, 240);
		
		var mesh08Geometry 	= new THREE.BoxGeometry(120, 120, 120);
		var mesh08Material 	= new THREE.MeshLambertMaterial({color: 0x0000ff});
		var mesh08			= new THREE.Mesh(mesh08Geometry, mesh08Material);
		scene.add(mesh08);
		mesh08.position.set(-240, 0,  0);
		
		var dotGeometry = new THREE.PlaneGeometry(.01, .01, 1, 1);
		var dotMaterial = new THREE.MeshLambertMaterial({color: 0x000000});
		var dot 		= new THREE.Mesh(dotGeometry, dotMaterial);
		dot.position.set(0,0,-2);
		camera.add(dot);
		
		var size = 240;
		var divisions = 10;
		var gridHelper = new THREE.GridHelper( 300, 100 );
		//scene.add( gridHelper );
		
		axisHelper = new THREE.AxisHelper( 50 );
		scene.add( axisHelper );
		
		//document.getElementById("WebGL-output").appendChild(renderer.domElement);
		
		jsonLoader = new THREE.JSONLoader(loadingManager);
        jsonLoader.load('../assets/models/enveloppe.json',
        function(geometry, materials) {
            enveloppe = new THREE.SkinnedMesh(geometry,
				new THREE.MeshPhongMaterial({
                normalScale: new THREE.Vector2(1, 2),
                specular: 0x2A2926,
                map: textureLoader.load('../assets/images/Enveloppe_Diffuse.jpg'),
                normalMap: textureLoader.load('../assets/images/Enveloppe_NormalMap.jpg'),
                specularMap: textureLoader.load('../assets/images/Enveloppe_SpecularMap.jpg'),
                skinning: true
            }));

                    enveloppe.geometry.computeVertexNormals();

                    mixer = new THREE.AnimationMixer(enveloppe);

                    action.idle = mixer.clipAction(geometry.animations[0]);
                    action.intro = mixer.clipAction(geometry.animations[1]);
                    action.ouverture = mixer.clipAction(geometry.animations[2]);

                    action.idle.setEffectiveWeight(1);
                    action.ouverture.setEffectiveWeight(1);

                    action.ouverture.setLoop(THREE.LoopOnce, 0);
                    action.ouverture.clampWhenFinished = true;

                    action.intro.setLoop(THREE.LoopOnce, 0);
                    action.intro.clampWhenFinished = true;

                    action.idle.enabled = true;
                    action.ouverture.enabled = true;

                    var position = {
						x: 120,
                        y: 30,
                        z: -160
                    };
                    enveloppe.position.x = position.x;
                    enveloppe.position.y = position.y;
                    enveloppe.position.z = position.z;
					
					
					//enveloppe.rotation.y = 2 * Math.PI;
					enveloppe.rotation.x = .2 - Math.PI;
					enveloppe.rotation.y = Math.PI;
					enveloppe.rotation.z = Math.PI;
					
					enveloppe.scale.set(4.5,4.5,4.5);
					
					scene.add(enveloppe);
				});
				
				
				jsonLoader.load('../assets/models/feuille.json',
                function(geometry, materials) {
                    feuille = new THREE.SkinnedMesh(geometry,
                        new THREE.MeshPhongMaterial({
                            map: textureLoader.load('../assets/images/Feuille_Diffuse.jpg'),
                            normalMap: textureLoader.load('../assets/images/Feuille_NormalMap.jpg'),
                            normalScale: new THREE.Vector2(.75, .75),
                            specularMap: textureLoader.load('../assets/images/Feuille_SpecularMap.jpg'),
                            specular: 0x2A2926,
                            shininess: 3,
                            skinning: true
                        }));

                    feuille.geometry.computeVertexNormals();

                    mixer2 = new THREE.AnimationMixer(feuille);

                    action2.idle2 = mixer2.clipAction(geometry.animations[0]);
                    action2.intro2 = mixer2.clipAction(geometry.animations[1]);
                    action2.ouverture2 = mixer2.clipAction(geometry.animations[2]);

                    action2.idle2.setEffectiveWeight(1);
                    action2.ouverture2.setEffectiveWeight(1);

                    action2.ouverture2.setLoop(THREE.LoopOnce, 0);
                    action2.ouverture2.clampWhenFinished = true;

                    action2.intro2.setLoop(THREE.LoopOnce, 0);
                    action2.intro2.clampWhenFinished = true;

                    action2.idle2.enabled = true;
                    action2.ouverture2.enabled = true;


                    var position2 = {
                        x: 120,
                        y: 30,
                        z: -160
                    };

                    feuille.position.x = position2.x;
                    feuille.position.y = position2.y;
                    feuille.position.z = position2.z;
					
					feuille.rotation.x = .2 - Math.PI;
					feuille.rotation.y = Math.PI;
					feuille.rotation.z = Math.PI;
					
					feuille.scale.set(4.5,4.5,4.5);

					scene.add(feuille);
                });
				
				jsonLoader.load('../assets/models/mount.json',
			function(geometry, materials) {
            mount = new THREE.Mesh(geometry,
				new THREE.MeshPhongMaterial({ }));

				
				mount.position.set( -440, -10, -440 );
				
                    /*
					
                    enveloppe.position.x = position.x;
                    enveloppe.position.y = position.y;
                    enveloppe.position.z = position.z;
					
					
					//enveloppe.rotation.y = 2 * Math.PI;
					enveloppe.rotation.x = .2 - Math.PI;
					enveloppe.rotation.y = Math.PI;
					enveloppe.rotation.z = Math.PI;
					
					enveloppe.scale.set(4.5,4.5,4.5);
					
					*/
					
					scene.add(mount);
					
				
				});
				
                // Add boxes
                var halfExtents = new CANNON.Vec3(1,1,1);
                var boxShape = new CANNON.Box(halfExtents);
                var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
                for(var i=0; i<7; i++){
                    var x = ((Math.random()-0.5)*20) - 120 ;
                    var y = 1 + (Math.random()-0.5)*1;
                    var z = ((Math.random()-0.5)*20);
                    var boxBody = new CANNON.Body({ mass: 5 });
                    boxBody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh( boxGeometry, material );
                    world.addBody(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
                }


                // Add linked boxes
                var size = 0.5;
                var he = new CANNON.Vec3(size,size,size*0.1);
                var boxShape = new CANNON.Box(he);
                var mass = 0;
                var space = 0.1 * size;
                var N = 5, last;
                var boxGeometry = new THREE.BoxGeometry(he.x*2,he.y*2,he.z*2);
                for(var i=0; i<N; i++){
                    var boxbody = new CANNON.Body({ mass: mass });
                    boxbody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh(boxGeometry, material);
                    boxbody.position.set(5,(N-i)*(size*2+2*space) + size*2+space, 120);
                    boxbody.linearDamping = 0.01;
                    boxbody.angularDamping = 0.01;
                    // boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    world.addBody(boxbody);
                    scene.add(boxMesh);
                    boxes.push(boxbody);
                    boxMeshes.push(boxMesh);

                    if(i!=0){
                        // Connect this body to the last one
                        var c1 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(-size,size+space,0),last,new CANNON.Vec3(-size,-size-space,0));
                        var c2 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(size,size+space,0),last,new CANNON.Vec3(size,-size-space,0));
                        world.addConstraint(c1);
                        world.addConstraint(c2);
                    } else {
                        mass=0.3;
                    }
                    last = boxbody;
                }
				
				var enveloppeCatcherGeometry = new THREE.PlaneGeometry(30, 20, 1, 1);
				var enveloppeCatcherMaterial = new THREE.MeshLambertMaterial({color: 0xFF0000, wireframe: true, transparent: true, opacity: 0 });
				var enveloppeCatcher = new THREE.Mesh(enveloppeCatcherGeometry, enveloppeCatcherMaterial);
				
				enveloppeCatcher.position.set(120, 15, -144);
				
				enveloppeCatcher.rotation.x = -Math.PI;
				enveloppeCatcher.rotation.z = Math.PI;
				enveloppeCatcher.rotation.y = Math.PI;
				scene.add(enveloppeCatcher);
				object03.push(enveloppeCatcher);
				
				clock = new THREE.Clock();
				
				raycaster = new THREE.Raycaster();
				//raycaster.set( camera.getWorldPosition(), camera.getWorldDirection() );
				mouse = new THREE.Vector2();
				// add the output of the renderer to the html element
				//document.getElementById("WebGL-output").appendChild(renderer.domElement);
				document.addEventListener('mousedown', onDocumentMouseDown, false);
            }
			
			
			
			function onDocumentMouseDown(event) { 
            //event.preventDefault();
            //mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            //mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera( new THREE.Vector2(), camera)
			
			var intersects = raycaster.intersectObjects(scene.children);
			
            var intersects01 = raycaster.intersectObjects(object01);

				if (intersects01.length > 0) {
						count01++;
						
						if(count01 % 2 == 0){
							rotation01 = true;
						}
						else{
							rotation01 = false;
						}
					}
			var intersects02 = raycaster.intersectObjects(object02);

				if (intersects02.length > 0) {              		
					count02++;
						
					if(count02 % 2 == 0){
						rotation02 = true;
					}
					else{
						rotation02 = false;
					}
				}
			
			//** Enveloppe trigger **//
			var intersects03 = raycaster.intersectObjects(object03);

				if (intersects03.length > 0) {              		
					count03++;
						
					if(count03 % 2 == 0){
						action.idle.stop();
						action.ouverture.play();
						action2.idle2.stop();
						action2.ouverture2.play();
						
						console.log("salut");
						
					}
					else{
						rotation03 = false;
					}
				}		
			}

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            var dt = 1/60;

			
			
			function animate(){
				
				

					//delta2 = clock.getDelta();
			
				
				setTimeout( function() {
				requestAnimationFrame( animate );
				}, 1000 / 60 );
				TWEEN.update();
			//requestAnimationFrame(animate);
				if(loadingComplete){
					render();
				}
			}
			
    function render() {
				
		cubeBBox.setFromObject(trigger00);
					
		if(sphereBBox.intersectsBox(cubeBBox)  ){
			var collisionDetected = true;
			
		}			
		
		if(collisionDetected){
			//mesh01.rotation.y += .01;
			//trigger00.position.y = -1.8;
			mesh01.rotation.y += .001;			
			//trigger00.rotation.y += .001;
			new TWEEN.Tween(trigger00.position).to({
					x: -90,
                    y: -2,
                    z: -120
                }, 2000)
                .easing(TWEEN.Easing.Linear.None).start();
							
			new TWEEN.Tween(trigger00Body.position).to({
                    x: -90,
                    y: -2,
                    z: -120
				}, 2000)
                .easing(TWEEN.Easing.Linear.None).start();	
		}
					
		AABBtrigger02.setFromObject(trigger02);
		if(sphereBBox.intersectsBox(AABBtrigger02)){
				
			collisionDetected02 = true;
		}
			
		if(collisionDetected02){
			
			//controlsEnabled = false;
			//controls.getObject().position.set(120, 5, -36);
			//PointerLockControls.cannonBody.position.z -= .07;
			
			//controls.getObject().position.z -= .07;
			//controls.getObject().rotation.set = .05 * Math.PI;
				
			sound.play();
			action.idle.play();
			action2.idle2.play();
			//collisionDetected03 = false;
		}
			
		AABBtrigger03.setFromObject(trigger03);
		if(sphereBBox.intersectsBox(AABBtrigger03)){			
			collisionDetected03 = true;
		}
			
		if(collisionDetected03){
			//collisionDetected02 = false;
			//controls.getObject().position.set(120, 5, -60);
			
			action.idle.stop();
			action2.idle2.stop();
			action.ouverture.play();
			action2.ouverture2.play();
		}
					
					
		mixer.update(dt);
		mixer2.update(dt);
				               
        if(controls.enabled){
        world.step(dt);

		//mixer2.update(delta2);

                    // Update ball positions
                    for(var i=0; i<balls.length; i++){
                        ballMeshes[i].position.copy(balls[i].position);
                        ballMeshes[i].quaternion.copy(balls[i].quaternion);
                    }

                    // Update box positions
                    for(var i=0; i<boxes.length; i++){
                        boxMeshes[i].position.copy(boxes[i].position);
                        boxMeshes[i].quaternion.copy(boxes[i].quaternion);
                    }
                }

                controls.update( (Date.now() - time) * 8 );
				
				
				/*
				loadingManager.onLoad = function(){
					renderer.render( Scene, camera );
				}
				*/
				renderer.render( scene, camera );
				
                time = Date.now();

            }
			/*
            var ballShape = new CANNON.Sphere(0.2);
            var ballGeometry = new THREE.SphereGeometry(ballShape.radius, 32, 32);
            var shootDirection = new THREE.Vector3();
            var shootVelo = 15;
            var projector = new THREE.Projector();
            function getShootDir(targetVec){
                var vector = targetVec;
                targetVec.set(0,0,1);
                projector.unprojectVector(vector, camera);
                var ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize() );
                targetVec.copy(ray.direction);
            }
			
			*/
			/*
			var shootDirection = new THREE.Vector3();
            window.addEventListener("click",function(e){
                if(controls.enabled==true){
                    var x = sphereBody.position.x;
                    var y = sphereBody.position.y;
                    var z = sphereBody.position.z;
                    var ballBody = new CANNON.Body({ mass: 1 });
                    ballBody.addShape(ballShape);
                    var ballMesh = new THREE.Mesh( ballGeometry, material );
                    world.addBody(ballBody);
                    scene.add(ballMesh);
                    ballMesh.castShadow = true;
                    ballMesh.receiveShadow = true;
                    balls.push(ballBody);
                    ballMeshes.push(ballMesh);
                    //getShootDir(shootDirection);
                    ballBody.velocity.set(  shootDirection.x * shootVelo,
                                            shootDirection.y * shootVelo,
                                            shootDirection.z * shootVelo);

                    // Move the ball outside the player sphere
                    x += shootDirection.x * (sphereShape.radius*1.02 + ballShape.radius);
                    y += shootDirection.y * (sphereShape.radius*1.02 + ballShape.radius);
                    z += shootDirection.z * (sphereShape.radius*1.02 + ballShape.radius);
                    ballBody.position.set(x,y,z);
                    ballMesh.position.set(x,y,z);
                }
            });
			*/

        </script>
    </body>
</html>