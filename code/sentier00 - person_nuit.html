<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>namecode: Sentiers</title>
        <style>
            html, body {
                width: 100%;
                height: 100%;
            }

            body {
                background-color: #ffffff;
                margin: 0;
                overflow: hidden;
                font-family: Liberation Mono;
            }

            #blocker {

                position: absolute;

                width: 100%;
                height: 100%;

                background-color: rgba(0,0,0,0.5);

            }

            #instructions {

                width: 100%;
                height: 100%;

                display: -webkit-box;
                display: -moz-box;
                display: box;

                -webkit-box-orient: horizontal;
                -moz-box-orient: horizontal;
                box-orient: horizontal;

                -webkit-box-pack: center;
                -moz-box-pack: center;
                box-pack: center;

                -webkit-box-align: center;
                -moz-box-align: center;
                box-align: center;

                color: #ffffff;
                text-align: center;
				height: 500px;

                cursor: pointer;

            }

        </style>
    </head>
    <body>
        <script src="../libs/three84.js"></script>
        <script src="../libs/cannon.js"></script>
        <script src="../libs/PointerLockControls.js"></script>
		<script src="../libs/Tween.js"></script>


        <div id="blocker">

            <div id="instructions">
                <span style="font-size:70px">namecode: Sentiers</span>
                <br />
            </div>

			<div id="WebGL-output">
			</div>


        </div>

        <script>

            var blocker = document.getElementById( 'blocker' );
            var instructions = document.getElementById( 'instructions' );

            var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

            if ( havePointerLock ) {

                var element = document.body;

                var pointerlockchange = function ( event ) {

                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

						controlsEnabled = true;
                        controls.enabled = true;


                        blocker.style.display = 'none';

                    } else {

                        controls.enabled = false;

                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';

                        instructions.style.display = '';

                    }

                }

                var pointerlockerror = function ( event ) {
                    instructions.style.display = '';
                }


                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

                instructions.addEventListener( 'click', function ( event ) {
                    instructions.style.display = 'none';
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

                    if ( /Firefox/i.test( navigator.userAgent ) ) {

                        var fullscreenchange = function ( event ) {

                            if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

                                document.removeEventListener( 'fullscreenchange', fullscreenchange );
                                document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

                                element.requestPointerLock();
                            }
                        }

                        document.addEventListener( 'fullscreenchange', fullscreenchange, false );
                        document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

                        element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
                        element.requestFullscreen();
                    }
					else {
                        element.requestPointerLock();
					}
                }, false);
            } else {
                instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
            }

			THREE.Sphere.__closest = new THREE.Vector3();
			THREE.Sphere.prototype.intersectsBox = function (box) {
			// get box closest point to sphere center by clamping
			THREE.Sphere.__closest.set(this.center.x, this.center.y, this.center.z);
			THREE.Sphere.__closest.clamp(box.min, box.max);

			var distance =  this.center.distanceToSquared(THREE.Sphere.__closest);
			return distance < (this.radius * this.radius);
			};

			var sphereShape, sphereBody, world, physicsMaterial, walls=[], balls=[], ballMeshes=[], boxes=[], boxMeshes=[];

            var camera, topCamera, gameplayCamera;
			var turnCameraRight;
			var turnCameraLeft;
			var playerDummy;
			var scene, renderer;

			var ambientLight, spotLight;


			// ** Audio ** //
			var listener, sound, audioLoader, play;

            var geometry, material, mesh;
			var floor;
			var controlsEnabled = false;
            var controls, time = Date.now();
			var objects = [];
			var action = {}, action2 = {};
			var mixer, mixer2;
			var clock, delta2;

			var object01 = [], object02 = [],
				object03 = [];

			var count01 = 1, count02 = 1,
				count03 = 1;

			var jsonLoader;
			var enveloppe;
			var feuille;
			var enveloppeCatcher;


			var loadingManager;
			var loadingComplete;

			var radius = 3.5;

			var collisionDetected, collisionDetected02, collisionDetected03;

			var trigger00, trigger00Body;
			var cubeBBox;
			var sphereBBox;
			var greatSphereBody;
			var greatSphere2;

			var trigger02, trigger03, AABBtrigger02, AABBtrigger03;

			var mesh01;

            initCannon();
            init();
            animate();

        function initCannon(){
                // Setup our world
                world = new CANNON.World();
                world.quatNormalizeSkip = 0;
                world.quatNormalizeFast = false;

                var solver = new CANNON.GSSolver();

                world.defaultContactMaterial.contactEquationStiffness = 1e9;
				world.defaultContactMaterial.contactEquationRelaxation = 4;

                solver.iterations = 7;
                solver.tolerance = 0.1;
                var split = true;
                if(split)
                    world.solver = new CANNON.SplitSolver(solver);
                else
                    world.solver = solver;

                world.gravity.set(0,-100,0);
                world.broadphase = new CANNON.NaiveBroadphase();

                // Create a slippery material (friction coefficient = 0.0)
                physicsMaterial = new CANNON.Material("slipperyMaterial");
                var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
                                                                        physicsMaterial,
                                                                        0.0, // friction coefficient
                                                                        0.3  // restitution
                                                                        );
                // We must add the contact materials to the world
                world.addContactMaterial(physicsContactMaterial);

                // Create a sphere
                var mass = 1;
                sphereShape = new CANNON.Sphere(radius);
                sphereBody = new CANNON.Body({ mass: mass });
                sphereBody.addShape(sphereShape);
				sphereBody.position.set(300, 5, 187.5);
                //sphereBody.position.set(300,5,187.5);
                sphereBody.linearDamping = 0.9;
                world.addBody(sphereBody);

                // Create a plane
                var groundShape = new CANNON.Plane();
                var groundBody = new CANNON.Body({ mass: 0 });

                groundBody.addShape(groundShape);
				groundBody.position.set(0,0,0);
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
                world.addBody(groundBody);
            }

	function Stars(){

		var geom = new THREE.Geometry();
        var vertices = []
        vertices.add( new THREE.Vector3() )
        var numberOfPoints = 10;

        var angle = -360 / numberOfPoints;
        for(var v = 1; v < vertices.length; v++){
            vertices[v] = new THREE.Quaternion(0, 0 , angle * (v -1 ) * point)
        }

		var v1 = new THREE.Vector3(0,0,0);
		var v2 = new THREE.Vector3(0,500,0);
		var v3 = new THREE.Vector3(0,500,500);

		geom.vertices.push(v1);
		geom.vertices.push(v2);
		geom.vertices.push(v3);

		geom.faces.push( new THREE.Face3( 0, 1, 2 ) );
		geom.computeFaceNormals();

		var object = new THREE.Mesh( geom, new THREE.MeshNormalMaterial() );

		//object.position.z = 100;//move a bit back - size of 500 is a bit big
		object.position.set(300, 5, 187.5)
		object.rotation.y = -Math.PI * .5;//triangle is pointing in depth, rotate it -90 degrees on Y

		scene.add(object);
	}

    function init() {

		///// L O A D I N G   M A N A G E R /////
		loadingManager = new THREE.LoadingManager();
		textureLoader = new THREE.TextureLoader(loadingManager);

		loadingManager.onLoad = function ( ) {
			loadingComplete = true;
			console.log( 'Loading complete!');
		};

		// CAMERA
		gameplayCamera = true;
		//top camera

		topCamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 1000 );
		topCamera.position.z = 50;
		topCamera.position.y = 10;


		//topCamera.rotation.y = 1 * Math.PI;
		//topCamera.updateMatrixWorld();

		//camera chase
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 1000 );
		//camera.position.set(300, 10,100);
		//camera.rotation.y = 1 * Math.PI;


		container = document.createElement( 'div' );
		document.body.appendChild( container );

        scene = new THREE.Scene();
        //scene.fog = new THREE.Fog( 0xffffff, 0, 500 );

		//topCamera.lookAt(playerDummy.position);

		//topCamera.rotation.y = -.25 * Math.PI;

		ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
		scene.add(ambientLight);

		var sunPositionX = 0;
		var sunPositionY = 500;
		var sunPositionZ = 825;

        light = new THREE.DirectionalLight( 0xFEFFF3, 0.5  );
        light.position.set( sunPositionX, sunPositionY, sunPositionZ );
		scene.add( light );

		spotLight = new THREE.SpotLight( 0xffcccc, 1.27);
        spotLight.position.set(175 , 30, 787.5 );
		spotLight.target.position.set(70, 40, 787.5);
		scene.add(spotLight.target);
       // scene.add(spotLight);

		function sky(){
			this.polar = new THREE.HemisphereLight(0xFF5632, 0x080820, .5);
			this.polar.position.set(70,40, 10000)
			//scene.add(this.polar);
		}



		//var moncieletoile = new sky();
		var moncieletoile = new Stars();





		listener = new THREE.AudioListener();
		camera.add(listener);
		sound = new THREE.Audio(listener);
		audioLoader = new THREE.AudioLoader();

	//Load a sound and set it as the Audio object's buffer
		audioLoader.load( '../assets/sounds/The_Monolith_On_The_Moon.ogg', function( buffer ) {
			sound.setBuffer( buffer );
			sound.setLoop(true);
			sound.setVolume(.9);
			//sound.play();
		});

		var spherePlayerGeometry = new THREE.SphereGeometry(radius);
		var spherePlayerMaterial = new THREE.MeshBasicMaterial({ color: 0x000000
															 	 //side: THREE.DoubleSide,
																 //wireframe: true
																 //transparent: true,
																 //opacity: .5

																 });

		var player		 = new THREE.Mesh(spherePlayerGeometry, spherePlayerMaterial);
		player.geometry.computeBoundingSphere();

		sphereBBox = new THREE.Sphere(player.position,
								player.geometry.boundingSphere.radius);
		scene.add(player);

        material = new THREE.MeshLambertMaterial( { color: 0xdddddd } );

		var bluesky = 0xE9F6F6
		var blacksky = 0x000000

        renderer = new THREE.WebGLRenderer(/*{antialias: true}*/);
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setClearColor( blacksky, 1 );



		var sunGeometry = new THREE.SphereGeometry(30, 10, 10, 0);
		var sunMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
		var sun			= new THREE.Mesh(sunGeometry, sunMaterial);
		light.add(sun);

		var sunGeometryWire = new THREE.SphereGeometry(30, 10, 10, 0);
		var sunMaterialWire = new THREE.MeshBasicMaterial({color: 0x000000, wireframe: true });
		var sunWire			= new THREE.Mesh(sunGeometryWire, sunMaterialWire);
		//light.add(sunWire);


		var floorGeometry = new THREE.PlaneGeometry(600, 1200, 1, 1);
        var floorMaterial = new THREE.MeshLambertMaterial({	color: 0x8DDB7D/*0xBAFFA0*/      //0xE0FFD4
															//emissive: 0xffffff,
															//emissiveIntensity: 0
															});

        floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.receiveShadow = true;
		scene.add(floor);
		floor.position.z = 600;
		floor.position.x = 300;
		floor.rotation.x = 1.5 * Math.PI;
		floor.rotation.z = -1 * Math.PI;

		controls = new PointerLockControls( camera, sphereBody, player);
        scene.add( controls.getObject() );
		controls.getObject().position.set(300, 5, 187.5);
		controls.getObject().rotation.y =  Math.PI;


		var playerDummyGeometry = new THREE.SphereGeometry(radius);
		var playerDummyMaterial = new THREE.MeshLambertMaterial({color: 0x000000});
			playerDummy			= new THREE.Mesh(playerDummyGeometry, playerDummyMaterial);
		scene.add(playerDummy);

		playerDummy.add(topCamera);

        document.body.appendChild( renderer.domElement );
        window.addEventListener( 'resize', onWindowResize, false );


				window.addEventListener("gamepadconnected", function(e) {
			console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
			e.gamepad.index, e.gamepad.id,
			e.gamepad.buttons.length, e.gamepad.axes.length);
		});

		/*
		window.addEventListener("gamepadconnected", function(e) {
			var gp = navigator.getGamepads()[0];
			console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
			gp.index, gp.id,
			gp.buttons.length, gp.axes.length);
		});
		/*

		window.addEventListener("gamepaddisconnected", function(e) {
  console.log("Gamepad disconnected from index %d: %s",
    e.gamepad.index, e.gamepad.id);
});

		/*
		window.addEventListener("gamepadconnected", function(e) {
			console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
			e.gamepad.index, e.gamepad.id,
			e.gamepad.buttons.length, e.gamepad.axes.length);
		});
		*/



		var bushes00Geometry = new THREE.BoxGeometry(6, 6, 12);
		var bushes00Material = new THREE.MeshBasicMaterial({color: 0x0000ff});
		var bushes00		 = new THREE.Mesh(bushes00Geometry, bushes00Material);
		scene.add(bushes00);
		bushes00.position.set(318, 5, 230);

		var papillon00Geometry = new THREE.BoxGeometry(1, 1, 1);
		var papillon00Material = new THREE.MeshBasicMaterial({color: 0xFF0000});
		var papillon00		   = new THREE.Mesh(papillon00Geometry, papillon00Material);
		scene.add(papillon00);
		papillon00.position.set(313, 5, 230);

		var mesh01Geometry 	= new THREE.SphereGeometry(90, 32, 32, 0);
		var mesh01Material 	= new THREE.MeshBasicMaterial({wireframe: true, color: 0xFF0000});
		mesh01			= new THREE.Mesh(mesh01Geometry, mesh01Material);
		scene.add(mesh01);
		mesh01.position.set(400, 30, 750);

		var halfExtentsTrigger00 = new CANNON.Vec3(15,25,15);
		var trigger00Shape = new CANNON.Box(halfExtentsTrigger00);
			trigger00Body = new CANNON.Body({ mass: 0 });
		trigger00Body.addShape(trigger00Shape);
		world.addBody(trigger00Body);



		trigger00Body.position.set(305,-24,515);

		var trigger00Geometry = new THREE.BoxGeometry(30, 50, 30, 6, 6, 6);
		var trigger00Material = new THREE.MeshLambertMaterial({color: 0xFF00FF, transparent: true, opacity: 1});
			trigger00 		  = new THREE.Mesh(trigger00Geometry, trigger00Material);
		cubeBBox = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
		scene.add(trigger00);
		trigger00.position.set(305, -24, 515);

		var trigger02Geometry = new THREE.BoxGeometry( 6, 30, 4, 1, 1 );
		var trigger02Material = new THREE.MeshLambertMaterial({color: 0xFF00FF, transparent: true, opacity: 0.2});
			trigger02 		  =	new THREE.Mesh(trigger02Geometry, trigger02Material);
			AABBtrigger02 	  = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
		scene.add(trigger02);
		trigger02.position.set(175, -16, 787.5);

		var trigger03Geometry = new THREE.BoxGeometry( 40, 30, 4, 1, 1 );
		var trigger03Material = new THREE.MeshLambertMaterial({color: 0xFF00FF, transparent: true, opacity: 0});
			trigger03 		  =	new THREE.Mesh(trigger03Geometry, trigger03Material);
			AABBtrigger03 	  = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
		scene.add(trigger03);
		trigger03.position.set(117, 0, 787.5);
		trigger03.rotation.x = - Math.PI;
		trigger03.rotation.y = .5 * Math.PI;
		trigger03.rotation.z =  Math.PI;



		//SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)
		var greatSphereGeometry = new THREE.SphereGeometry(75, 24, 24, 0);
		var greatSphereMaterial = new THREE.MeshBasicMaterial({color: 0x0000FF, side: THREE.DoubleSide});
		greatSphere 			= new THREE.Mesh(greatSphereGeometry, greatSphereMaterial);
		scene.add(greatSphere);
		greatSphere.position.set(112.5, 30, 787.5);

		var greatSphereGeometry = new THREE.SphereGeometry(75.08, 24, 24, 0);
		var greatSphereMaterial = new THREE.MeshBasicMaterial({color: 0x00000f, wireframe: true});
		greatSphere2 			= new THREE.Mesh(greatSphereGeometry, greatSphereMaterial);
		scene.add(greatSphere2);
		greatSphere2.position.set(112.5, 30, 787.5);


		var greatSphereShape = new CANNON.Sphere(75);
		greatSphereBody 	 = new CANNON.Body({ mass: 0 });
		greatSphereBody.addShape(greatSphereShape);
		world.addBody(greatSphereBody);
		greatSphereBody.position.set(112.5,30,787.5);

		var arc00Geometry = new THREE.BoxGeometry(150, 50, 10);
		var arc00Material = new THREE.MeshLambertMaterial({color: 0xFFFFFF, side: THREE.DoubleSide});
		var arc00		  = new THREE.Mesh(arc00Geometry, arc00Material);
		scene.add(arc00);
		arc00.position.set(377, 25, 400);



		var halfExtents00 = new CANNON.Vec3(75,25,5);
		var arc00Shape = new CANNON.Box(halfExtents00);
		var arc00Body = new CANNON.Body({ mass: 0 });
		arc00Body.addShape(arc00Shape);
		world.addBody(arc00Body);
		arc00Body.position.set(377,25,400);

		var arc01Geometry = new THREE.BoxGeometry(150, 50, 10);
		var arc01Material = new THREE.MeshLambertMaterial({color: 0xFFFFFF, side: THREE.DoubleSide});
		var arc01		  = new THREE.Mesh(arc01Geometry, arc01Material);
		scene.add(arc01);
		arc01.position.set(210, 25, 400);

		var halfExtents01 = new CANNON.Vec3(75,25,5);
		var arc01Shape = new CANNON.Box(halfExtents01);
		var arc01Body = new CANNON.Body({ mass: 0 });
		arc01Body.addShape(arc01Shape);
		world.addBody(arc01Body);
		arc01Body.position.set(210,25,400);

		var arc02Geometry = new THREE.BoxGeometry(30, 35, 10);
		var arc02Material = new THREE.MeshLambertMaterial({color: 0xFFFFFF, side: THREE.DoubleSide});
		var arc02		  = new THREE.Mesh(arc02Geometry, arc02Material);
		scene.add(arc02);
		arc02.position.set(295, 32.5, 400);



		var dotGeometry = new THREE.PlaneGeometry(.01, .01, 1, 1);
		var dotMaterial = new THREE.MeshLambertMaterial({color: 0x000000});
		var dot 		= new THREE.Mesh(dotGeometry, dotMaterial);
		dot.position.set(0,0,-2);
		camera.add(dot);

		var size = 240;
		var divisions = 10;
		var gridHelper = new THREE.GridHelper( 1000, 100 );
		//scene.add( gridHelper );

		axisHelper = new THREE.AxisHelper( 50 );
		scene.add( axisHelper );

		//document.getElementById("WebGL-output").appendChild(renderer.domElement);

		jsonLoader = new THREE.JSONLoader(loadingManager);
        jsonLoader.load('../assets/models/enveloppe.json',
        function(geometry, materials) {
            enveloppe = new THREE.SkinnedMesh(geometry,
				new THREE.MeshPhongMaterial({
                normalScale: new THREE.Vector2(1, 2),
                specular: 0x2A2926,
                map: textureLoader.load('../assets/images/Enveloppe_Diffuse.jpg'),
                normalMap: textureLoader.load('../assets/images/Enveloppe_NormalMap.jpg'),
                specularMap: textureLoader.load('../assets/images/Enveloppe_SpecularMap.jpg'),
                skinning: true
            }));

                    enveloppe.geometry.computeVertexNormals();

                    mixer = new THREE.AnimationMixer(enveloppe);

                    action.idle = mixer.clipAction(geometry.animations[0]);
                    action.intro = mixer.clipAction(geometry.animations[1]);
                    action.ouverture = mixer.clipAction(geometry.animations[2]);

                    action.idle.setEffectiveWeight(1);
                    action.ouverture.setEffectiveWeight(1);

                    action.ouverture.setLoop(THREE.LoopOnce, 0);
                    action.ouverture.clampWhenFinished = true;

                    action.intro.setLoop(THREE.LoopOnce, 0);
                    action.intro.clampWhenFinished = true;

                    action.idle.enabled = true;
                    action.ouverture.enabled = true;

                    var position = {
						x: 70,
                        y: 40,
                        z: 787.5
                    };
                    enveloppe.position.x = position.x;
                    enveloppe.position.y = position.y;
                    enveloppe.position.z = position.z;


					//enveloppe.rotation.y = 2 * Math.PI;
					enveloppe.rotation.x =  -  Math.PI ;
					enveloppe.rotation.y = .5 * Math.PI;
					enveloppe.rotation.z = Math.PI;

					enveloppe.scale.set(4.5,4.5,4.5);
					//action.idle.play();
					scene.add(enveloppe);
				});


				jsonLoader.load('../assets/models/feuille.json',
                function(geometry, materials) {
                    feuille = new THREE.SkinnedMesh(geometry,
                        new THREE.MeshPhongMaterial({
                            map: textureLoader.load('../assets/images/brave_diffuse.jpg'),
                            normalMap: textureLoader.load('../assets/images/Feuille_NormalMap.jpg'),
                            normalScale: new THREE.Vector2(.75, .75),
                            specularMap: textureLoader.load('../assets/images/Feuille_SpecularMap.jpg'),
                            specular: 0x2A2926,
                            shininess: 3,
                            skinning: true
                        }));

                    feuille.geometry.computeVertexNormals();

                    mixer2 = new THREE.AnimationMixer(feuille);

                    action2.idle2 = mixer2.clipAction(geometry.animations[0]);
                    action2.intro2 = mixer2.clipAction(geometry.animations[1]);
                    action2.ouverture2 = mixer2.clipAction(geometry.animations[2]);

                    action2.idle2.setEffectiveWeight(1);
                    action2.ouverture2.setEffectiveWeight(1);

                    action2.ouverture2.setLoop(THREE.LoopOnce, 0);
                    action2.ouverture2.clampWhenFinished = true;

                    action2.intro2.setLoop(THREE.LoopOnce, 0);
                    action2.intro2.clampWhenFinished = true;

                    action2.idle2.enabled = true;
                    action2.ouverture2.enabled = true;


                    var position2 = {
                        x: 70,
                        y: 40,
                        z: 787.5
                    };

                    feuille.position.x = position2.x;
                    feuille.position.y = position2.y;
                    feuille.position.z = position2.z;

					feuille.rotation.x = - Math.PI;
					feuille.rotation.y = .5 * Math.PI;
					feuille.rotation.z = Math.PI;

					feuille.scale.set(4.5,4.5,4.5);
					//action2.idle2.play();
					scene.add(feuille);
                });


				var enveloppeCatcherGeometry = new THREE.PlaneGeometry(30, 20, 1, 1);
				var enveloppeCatcherMaterial = new THREE.MeshLambertMaterial({color: 0xFF0000, wireframe: true /*, transparent: true, opacity: 0 */});
				 enveloppeCatcher = new THREE.Mesh(enveloppeCatcherGeometry, enveloppeCatcherMaterial);

				enveloppeCatcher.position.set(20, 30, 800);

				enveloppeCatcher.rotation.x = - Math.PI;
				enveloppeCatcher.rotation.z = .4 * Math.PI;
				enveloppeCatcher.rotation.y = Math.PI;
				scene.add(enveloppeCatcher);
				object03.push(enveloppeCatcher);


				jsonLoader.load('../assets/models/mount.json',
			function(geometry, materials) {
            mount = new THREE.Mesh(geometry,
				new THREE.MeshPhongMaterial({ }));

				mount.position.set( 700, -10, 187.5 );
					scene.add(mount);

				var mount2 = mount.clone();
				mount2.position.set( -125, -10, 187.5 );
				scene.add(mount2);

				var mount3 = mount.clone();
				mount3.position.set( 284, -10, -400);
				scene.add(mount3);

				var mount4 = mount.clone();
				mount4.position.set( 700, -10, 600);
				scene.add(mount4);

				var mount5 = mount.clone();
				mount5.position.set( -250, -10, 830);
				scene.add(mount5);

				});

                // Add boxes
                var halfExtents = new CANNON.Vec3(1,1,1);
                var boxShape = new CANNON.Box(halfExtents);
                var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
                for(var i=0; i<7; i++){
                    var x = ((Math.random()-0.5)*20) - 120 ;
                    var y = 1 + (Math.random()-0.5)*1;
                    var z = ((Math.random()-0.5)*20);
                    var boxBody = new CANNON.Body({ mass: 5 });
                    boxBody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh( boxGeometry, material );
                    world.addBody(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
                }


                // Add linked boxes
                var size = 1.3;
                var he = new CANNON.Vec3(size,size,size*0.1);
                var boxShape = new CANNON.Box(he);
                var mass = 0;
                var space = 0.1 * size;
                var N = 5, last;
                var boxGeometry = new THREE.BoxGeometry(he.x*2,he.y*2,he.z*2);
                for(var i=0; i<N; i++){
                    var boxbody = new CANNON.Body({ mass: mass });
                    boxbody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh(boxGeometry, material);
                    boxbody.position.set(300,((N-i)*(size*2+2*space) + size*2+space) -3.8 , 400);
                    boxbody.linearDamping = 0.01;
                    boxbody.angularDamping = 0.01;
                    // boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    world.addBody(boxbody);
                    scene.add(boxMesh);
                    boxes.push(boxbody);
                    boxMeshes.push(boxMesh);

                    if(i!=0){
                        // Connect this body to the last one
                        var c1 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(-size,size+space,0),last,new CANNON.Vec3(-size,-size-space,0));
                        var c2 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(size,size+space,0),last,new CANNON.Vec3(size,-size-space,0));
                        world.addConstraint(c1);
                        world.addConstraint(c2);
                    } else {
                        mass=0.3;
                    }
                    last = boxbody;
                }

				var size = 1.3;
                var he = new CANNON.Vec3(size,size,size*0.1);
                var boxShape = new CANNON.Box(he);
                var mass = 0;
                var space = 0.1 * size;
                var N = 5, last;
                var boxGeometry = new THREE.BoxGeometry(he.x*2,he.y*2,he.z*2);
                for(var i=0; i<N; i++){
                    var boxbody = new CANNON.Body({ mass: mass });
                    boxbody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh(boxGeometry, material);
                    boxbody.position.set(297,((N-i)*(size*2+2*space) + size*2+space) -3.8 , 401);
                    boxbody.linearDamping = 0.01;
                    boxbody.angularDamping = 0.01;
                    // boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    world.addBody(boxbody);
                    scene.add(boxMesh);
                    boxes.push(boxbody);
                    boxMeshes.push(boxMesh);

                    if(i!=0){
                        // Connect this body to the last one
                        var c1 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(-size,size+space,0),last,new CANNON.Vec3(-size,-size-space,0));
                        var c2 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(size,size+space,0),last,new CANNON.Vec3(size,-size-space,0));
                        world.addConstraint(c1);
                        world.addConstraint(c2);
                    } else {
                        mass=0.3;
                    }
                    last = boxbody;
                }

								var size = 1.3;
                var he = new CANNON.Vec3(size,size,size*0.1);
                var boxShape = new CANNON.Box(he);
                var mass = 0;
                var space = 0.1 * size;
                var N = 5, last;
                var boxGeometry = new THREE.BoxGeometry(he.x*2,he.y*2,he.z*2);
                for(var i=0; i<N; i++){
                    var boxbody = new CANNON.Body({ mass: mass });
                    boxbody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh(boxGeometry, material);
                    boxbody.position.set(293.5,((N-i)*(size*2+2*space) + size*2+space) -3.8 , 400);
                    boxbody.linearDamping = 0.01;
                    boxbody.angularDamping = 0.01;
                    // boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    world.addBody(boxbody);
                    scene.add(boxMesh);
                    boxes.push(boxbody);
                    boxMeshes.push(boxMesh);

                    if(i!=0){
                        // Connect this body to the last one
                        var c1 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(-size,size+space,0),last,new CANNON.Vec3(-size,-size-space,0));
                        var c2 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(size,size+space,0),last,new CANNON.Vec3(size,-size-space,0));
                        world.addConstraint(c1);
                        world.addConstraint(c2);
                    } else {
                        mass=0.3;
                    }
                    last = boxbody;
                }

												var size = 1.3;
                var he = new CANNON.Vec3(size,size,size*0.1);
                var boxShape = new CANNON.Box(he);
                var mass = 0;
                var space = 0.1 * size;
                var N = 5, last;
                var boxGeometry = new THREE.BoxGeometry(he.x*2,he.y*2,he.z*2);
                for(var i=0; i<N; i++){
                    var boxbody = new CANNON.Body({ mass: mass });
                    boxbody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh(boxGeometry, material);
                    boxbody.position.set(290,((N-i)*(size*2+2*space) + size*2+space) -3.8 , 400);
                    boxbody.linearDamping = 0.01;
                    boxbody.angularDamping = 0.01;
                    // boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    world.addBody(boxbody);
                    scene.add(boxMesh);
                    boxes.push(boxbody);
                    boxMeshes.push(boxMesh);

                    if(i!=0){
                        // Connect this body to the last one
                        var c1 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(-size,size+space,0),last,new CANNON.Vec3(-size,-size-space,0));
                        var c2 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(size,size+space,0),last,new CANNON.Vec3(size,-size-space,0));
                        world.addConstraint(c1);
                        world.addConstraint(c2);
                    } else {
                        mass=0.3;
                    }
                    last = boxbody;
                }

																var size = 1.3;
                var he = new CANNON.Vec3(size,size,size*0.1);
                var boxShape = new CANNON.Box(he);
                var mass = 0;
                var space = 0.1 * size;
                var N = 5, last;
                var boxGeometry = new THREE.BoxGeometry(he.x*2,he.y*2,he.z*2);
                for(var i=0; i<N; i++){
                    var boxbody = new CANNON.Body({ mass: mass });
                    boxbody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh(boxGeometry, material);
                    boxbody.position.set(287.5,((N-i)*(size*2+2*space) + size*2+space) -3.8 , 400);
                    boxbody.linearDamping = 0.01;
                    boxbody.angularDamping = 0.01;
                    // boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    world.addBody(boxbody);
                    scene.add(boxMesh);
                    boxes.push(boxbody);
                    boxMeshes.push(boxMesh);

                    if(i!=0){
                        // Connect this body to the last one
                        var c1 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(-size,size+space,0),last,new CANNON.Vec3(-size,-size-space,0));
                        var c2 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(size,size+space,0),last,new CANNON.Vec3(size,-size-space,0));
                        world.addConstraint(c1);
                        world.addConstraint(c2);
                    } else {
                        mass=0.3;
                    }
                    last = boxbody;
                }


				clock = new THREE.Clock();

				raycaster = new THREE.Raycaster();
				//raycaster.set( camera.getWorldPosition(), camera.getWorldDirection() );
				mouse = new THREE.Vector2();
				// add the output of the renderer to the html element
				//document.getElementById("WebGL-output").appendChild(renderer.domElement);
				document.addEventListener('mousedown', onDocumentMouseDown, false);
            }



			function onDocumentMouseDown(event) {
            //event.preventDefault();
            //mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            //mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera( new THREE.Vector2(), camera)

			var intersects = raycaster.intersectObjects(scene.children);

            var intersects01 = raycaster.intersectObjects(object01);

				if (intersects01.length > 0) {
						count01++;

						if(count01 % 2 == 0){
							rotation01 = true;
						}
						else{
							rotation01 = false;
						}
					}
			var intersects02 = raycaster.intersectObjects(object02);

				if (intersects02.length > 0) {
					count02++;

					if(count02 % 2 == 0){
						rotation02 = true;
					}
					else{
						rotation02 = false;
					}
				}

			//** Enveloppe trigger **//
			var intersects03 = raycaster.intersectObjects(object03);

				if (intersects03.length > 0) {
					count03++;

					if(count03 % 2 == 0){
						action.idle.stop();
						action.ouverture.play();
						action2.idle2.stop();
						action2.ouverture2.play();

						console.log("salut");

					}
					else{
						rotation03 = false;
					}
				}
			}

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            var dt = 1/60;



			function animate(){



					//delta2 = clock.getDelta();


				setTimeout( function() {
				requestAnimationFrame( animate );
				}, 1000 / 60 );
				TWEEN.update();
			//requestAnimationFrame(animate);
				if(loadingComplete){
					render();
				}
			}

    function render() {

		cubeBBox.setFromObject(trigger00);

		if(sphereBBox.intersectsBox(cubeBBox)  ){
			collisionDetected = true;

		}

		if(collisionDetected){
			//mesh01.rotation.y += .01;
			//trigger00.position.y = -1.8;
			mesh01.rotation.y += .001;
			//trigger00.rotation.y += .001;
			new TWEEN.Tween(trigger00.position).to({
					x: 305,
                    y: 20,
                    z: 515
                }, 4000)
                .easing(TWEEN.Easing.Linear.None).start();

			new TWEEN.Tween(trigger00Body.position).to({
                    x: 305,
                    y: 20,
                    z: 515
				}, 4000)
                .easing(TWEEN.Easing.Linear.None).start();

			new TWEEN.Tween(trigger02.position).to({
                   x: 185,
                   y: 0,
                   z: 787.5
				}, 4000)
                .easing(TWEEN.Easing.Linear.None).start();
		}


		AABBtrigger02.setFromObject(trigger02);
		if(sphereBBox.intersectsBox(AABBtrigger02)){

			collisionDetected02 = true;
		}

		if(collisionDetected02){

			//controlsEnabled = false;
			//controls.getObject().position.set(120, 5, -36);
			//PointerLockControls.cannonBody.position.z -= .07;

			//controls.getObject().position.z -= .07;
			//controls.getObject().rotation.set = .05 * Math.PI;
			//scene.remove(trigger03);



			world.removeBody(greatSphereBody);
			setTimeout( function() {
				scene.remove(ambientLight);
			}, 4000);

			setTimeout( function() {
				floor.material = new THREE.MeshLambertMaterial({color: 0X000000 });
				}, 4000);

			//scene.remove(greatSphere2);
			scene.add(spotLight);
			sound.play();
			action.idle.play();
			action2.idle2.play();
			//collisionDetected03 = false;
		}

		AABBtrigger03.setFromObject(trigger03);
		if(sphereBBox.intersectsBox(AABBtrigger03)){
			collisionDetected03 = true;
		}

		if(collisionDetected03){
			//collisionDetected02 = false;
			//controls.getObject().position.set(120, 5, -60);
			//controlsEnabled = false;
			spotLight.color.setHex(0xffffff);
			spotLight.intensity = 0.9;
			sound.stop();
			action.idle.stop();
			action2.idle2.stop();
			action.ouverture.play();
			action2.ouverture2.play();

		}


		mixer.update(dt);
		mixer2.update(dt);

        if(controls.enabled){
        world.step(dt);

		//mixer2.update(delta2);

                    // Update ball positions
                    for(var i=0; i<balls.length; i++){
                        ballMeshes[i].position.copy(balls[i].position);
                        ballMeshes[i].quaternion.copy(balls[i].quaternion);
                    }

                    // Update box positions
                    for(var i=0; i<boxes.length; i++){
                        boxMeshes[i].position.copy(boxes[i].position);
                        boxMeshes[i].quaternion.copy(boxes[i].quaternion);
                    }
                }

                controls.update( (Date.now() - time) * 8 );


				/*
				loadingManager.onLoad = function(){
					renderer.render( Scene, camera );
				}
				*/

				if(turnCameraRight == true){
					//playerDummy.rotation.y += .02;
					//cannonBody.rotation.y  += .02;
				}

				if(turnCameraLeft == true){
					//playerDummy.rotation.y -= .02;
				}



				if(gameplayCamera){
					renderer.render( scene, camera );
				}
				else{
					renderer.render(scene, topCamera);
				}
                time = Date.now();

            }
			/*
            var ballShape = new CANNON.Sphere(0.2);
            var ballGeometry = new THREE.SphereGeometry(ballShape.radius, 32, 32);
            var shootDirection = new THREE.Vector3();
            var shootVelo = 15;
            var projector = new THREE.Projector();
            function getShootDir(targetVec){
                var vector = targetVec;
                targetVec.set(0,0,1);
                projector.unprojectVector(vector, camera);
                var ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize() );
                targetVec.copy(ray.direction);
            }

			*/
			/*
			var shootDirection = new THREE.Vector3();
            window.addEventListener("click",function(e){
                if(controls.enabled==true){
                    var x = sphereBody.position.x;
                    var y = sphereBody.position.y;
                    var z = sphereBody.position.z;
                    var ballBody = new CANNON.Body({ mass: 1 });
                    ballBody.addShape(ballShape);
                    var ballMesh = new THREE.Mesh( ballGeometry, material );
                    world.addBody(ballBody);
                    scene.add(ballMesh);
                    ballMesh.castShadow = true;
                    ballMesh.receiveShadow = true;
                    balls.push(ballBody);
                    ballMeshes.push(ballMesh);
                    //getShootDir(shootDirection);
                    ballBody.velocity.set(  shootDirection.x * shootVelo,
                                            shootDirection.y * shootVelo,
                                            shootDirection.z * shootVelo);

                    // Move the ball outside the player sphere
                    x += shootDirection.x * (sphereShape.radius*1.02 + ballShape.radius);
                    y += shootDirection.y * (sphereShape.radius*1.02 + ballShape.radius);
                    z += shootDirection.z * (sphereShape.radius*1.02 + ballShape.radius);
                    ballBody.position.set(x,y,z);
                    ballMesh.position.set(x,y,z);
                }
            });
			*/

        </script>
    </body>
</html>