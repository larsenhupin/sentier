<!DOCTYPE html>

<html>

<head>
    <title>Example 02.04 - Geometries</title>
   
    <style>

		html, body {
			width: 100%;
			height: 100%;
		}
			
		body {
			background-color #ffffff;
			margin: 0;
			overflow: hidden;
			font-family: Liberation Mono;
		}
			
		#blocker {
			
			position: absolute;
				
			width: 100%;
			height: 100%;
				
			background-color: rgba(0,0,0,0.5);
				
		}
			
		#instructions {
				
			width: 100%;
			height: 100%;
				
			display: -webkit-box;
			display: -moz-box;
			display: box;
				
			-webkit-box-orient: horizontal;
			-moz-box-orient: horizontal;
			box-orient: horizontal;
				
			-webkit-box-pack: center;
			-moz-box-pack: center;
			box-pack: center;
				
			-webkit-box-align: center;
			-moz-box-align: center;
			box-align: center;
				
			color: #ffffff;
			text-align: center;
			height: 500px;
				
			cursor: pointer;
				
			}

		
    </style>
</head>
<body>
	<script src="../libs/three.min.js"></script>
	<script src="../libs/PointerLockControlsOriginal.js"></script>
	<script src="../libs/cannon.js"></script>
	
	<div id="blocker">
		
			<div id="instructions">
				<span style="font-size:70px">namecode: Sentiers</span>
				<br />
			</div>
		</div>

<div id="Stats-output">
</div>
<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

	var blocker = document.getElementById( 'blocker' );
	var instructions = document.getElementById( 'instructions' );

	var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
			
	if ( havePointerLock ) {
		var element = document.body;
				
		var pointerlockchange = function ( event ){	
			if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ){				
				controlsEnabled = true;
				controls.enabled = true;			
				blocker.style.display = 'none';
						
			}else {
						
				controls.enabled = false;
				blocker.style.display = '-webkit-box';
				blocker.style.display = '-moz-box';
				blocker.style.display = 'box';
				instructions.style.display = '';				
			}
		};
				
		var pointerlockerror = function ( event ) {				
			instruction.style.display = '';				
		};
				
		//Hook pointer lock state change events
		document.addEventListener( 'pointerlockchange', pointerlockchange, false );
		document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
		document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
				
		document.addEventListener( 'pointerlockerror', pointerlockerror, false );
		document.addEventListener( 'mozpointerlockerror', pointerlockerror,false );
		document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
				
		instructions.addEventListener( 'click', function ( event ){				
			instructions.style.display = 'none';
					
			//Ask the browser to lock the pointer
			element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
			element.requestPointerLock();
					
		}, false );
	} else {
				
		instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
				
		}
		
	var controlsEnabled = false;
			
	var moveForward = false;
	var moveBackward = false;
	var moveLeft = false;
	var moveRight = false;
	//var canJump = false;
			
	var prevTime = performance.now();
	var velocity = new THREE.Vector3();
	var start = false;
	var objects = [];
	var controls;
	var phiLength;
	var axisHelper
	var player;
	var collidableMeshList = [];
	var collidableMeshList2 = [];
	var collidableMeshList3 = [];
	var directionList = [];
	var positionMesh;
	var collision;
	var jsonLoader;
	var enveloppe;
	var feuille;
	var clock;
	var stop = false;
	var push;
	var what;
			
	var action = {}, action2 = {};
		
    var mixer, mixer2;
		
	var listener, sound, audioLoader, play;
			
	var container;
	var raycaster;
	var mouse;
	var scene;
	var camera;
	var renderer;
	var geoms;
	var ambientLight;
	var sphereShape, sphereBody, world, physicsMaterial, solver;

	var geometry, material, mesh;
	var mesh00, mesh01;
		
	var object01 = [], object02 = [],
		object03 = [], object04 = [],
		object05 = [], object06 = [],
		object07 = [], object08 = [],
		object09 = [], object10 = [],
		object11 = [];
		
	var rotation01, rotation02,
		rotation03, rotation04,
		rotation05, rotation06,
		rotation07, rotation08,
		rotation09, rotation10,
		rotation11;
	
	var count01 = 1, count02 = 1,
		count03 = 1, count04 = 1,
		count05 = 1, count06 = 1,
		count07 = 1, count08 = 1,
		count09 = 1, count10 = 1,
		count11 = 1;

	initCannon();
	init();
	animate();
		
		
	function initCannon(){
		world = new CANNON.World();
		world.quatNormalizeSkip = 0;
		world.quatNormalizeFast = false;
		
		var solver = new CANNON.GSSolver();
		
		world.defaultContactMaterial.contactEquationStiffness = 1e9;
        world.defaultContactMaterial.contactEquationRelaxation = 4;
		
		solver.iterations = 7;
        solver.tolerance = 0.1;
        var split = true;
        if(split){
           world.solver = new CANNON.SplitSolver(solver);
		}
        else{
			world.solver = solver;
		}
		
		world.gravity.set(0,-20,0);
		
		world.broadphase = new CANNON.NaiveBroadphase();
		
		 // Create a slippery material (friction coefficient = 0.0)
        physicsMaterial = new CANNON.Material("slipperyMaterial");
        var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
                                                                physicsMaterial,
                                                                0.0, // friction coefficient
                                                                0.3  // restitution
                                                                );
				
		world.addContactMaterial(physicsContactMaterial);
		
		var mass = 5, radius = 1.3;
        sphereShape = new CANNON.Sphere(radius);
        sphereBody = new CANNON.Body({ mass: mass });
        sphereBody.addShape(sphereShape);
        sphereBody.position.set(0,5,0);
        sphereBody.linearDamping = 0.9;
        world.addBody(sphereBody);
		
		// Create a plane
        var groundShape = new CANNON.Plane();
        var groundBody = new CANNON.Body({ mass: 0 });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
        world.addBody(groundBody);		
	}
		
    function init() {

            ///// L O A D I N G   M A N A G E R /////
    loadingManager = new THREE.LoadingManager();
    textureLoader = new THREE.TextureLoader(loadingManager);
	
    scene = new THREE.Scene();

    // create a camera, which defines where we're looking at.
    //camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
	camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000  );
	container = document.createElement( 'div' );
	document.body.appendChild( container );
		
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setClearColor(0xffffff);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = false;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;	
	//velocity.set(0,0,12);
		
	/*if (moveForward == false){
	camera.position.set( 0, 0, -120 );
	camera.__dirtyPosition = true;
	}*/
	//camera.add(player);
	//player.position.set(0, 0, -120);	
	//stats = new Stats();
	//container.appendChild( stats.dom );			
	//raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );	
    ambientLight = new THREE.AmbientLight(0xffffff, .5);
    scene.add(ambientLight);
	
    var spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(100, 100, 50);
    spotLight.castShadow = true;
    //scene.add(spotLight);

		
	controls = new THREE.PointerLockControls( camera, sphereBody);
	scene.add( controls.getObject() );
		
	var playerGeometry 	= new THREE.BoxGeometry(10, 15, 10, 1, 1, 1);
	var playerMaterial 	= new THREE.MeshLambertMaterial({color: 0xff0000  /*side: THREE.DoubleSide, wireframe: true*/});
	player				= new THREE.Mesh(playerGeometry, playerMaterial);
	//scene.add(player);
	//scene.add(camera);
	//player.position.z = -60;
	
	var onKeyDown = function ( event ) {					
		switch ( event.keyCode ) {				
			case 38: //up
			case 87: //w
			moveForward = true;
			break;
						
			case 37: //left
			case 65: //a
			moveLeft = true;
			break;
							
			case 40: //down
			case 83: //s
			moveBackward = true;
			break;
							
			case 39: //right
			case 68: //d
			moveRight = true;
			break;				
			/*case 32: //space
			if ( canJump === true ) velocity += 350;
				canJump = false;
				break;*/
						
		}
					
	};
	
	var onKeyUp = function ( event ) {				
		switch( event.keyCode ) {				
			case 38: //up
			case 87: //w
			moveForward = false;
			break;
							
			case 37: //left
			case 65: //a
			moveLeft = false;
			break;
							
			case 40: //down
			case 83: //s
			moveBackward = false;
			break;
						
			case 39: //right
			case 68: //d
			moveRight = false;
			break;		
		}
				
	};
	
	/*
	controls.getObject().position.z = -120;
	controls.getObject().rotation.y = .5 * Math.PI;
	*/
		
	scene.updateMatrixWorld(true);
	positionMesh = new THREE.Vector3();	
	positionMesh.getPositionFromMatrix( camera.matrixWorld );
	console.log(positionMesh.x + ',' + positionMesh.y + ',' + positionMesh.z);
	
	document.addEventListener( 'keydown', onKeyDown, false );
	document.addEventListener( 'keyup', onKeyUp, false );
		
	listener = new THREE.AudioListener();
	camera.add(listener);	
	sound = new THREE.Audio(listener);
	audioLoader = new THREE.AudioLoader();
		
	//Load a sound and set it as the Audio object's buffer
	audioLoader.load( '../assets/The_Monolith_On_The_Moon.ogg', function( buffer ) {
		sound.setBuffer( buffer );
		sound.setLoop(true);
		sound.setVolume(.7);
		//sound.play();
	});	
		   // floor
         /*       geometry = new THREE.PlaneGeometry( 600, 600, 50, 50 );
                geometry.rotation.x = -0.5 * Math.PI;

                material = new THREE.MeshLambertMaterial( { color: 0xFF0000 } );
				
				mesh = new THREE.Mesh( geometry, material );
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add( mesh );
				
				mesh.rotation.x = -0.5 * Math.PI;
		*/
		
		var planeGeometry = new THREE.PlaneGeometry(600, 600, 1, 1);
        var planeMaterial = new THREE.MeshLambertMaterial({color: 0x0000ff});
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.receiveShadow = true;

        // rotate and position the plane
		plane.rotation.x = -0.5 * Math.PI;	
       // plane.position.x = 0;
       // plane.position.y = 0;
       //plane.position.z = 0;
        scene.add(plane);
	
	
		/*
			*BoxGeometry
		
			width — Width of the sides on the X axis.
			height — Height of the sides on the Y axis.
			depth — Depth of the sides on the Z axis.
			widthSegments — Optional. Number of segmented faces along the width of the sides. Default is 1.
			heightSegments — Optional. Number of segmented faces along the height of the sides. Default is 1.
			depthSegments — Optional. Number of segmented faces along the depth of the sides. Default is 1.

			easy shit
			
		*/
	
		
		var wallGeometry = new THREE.PlaneGeometry(120, 120, 1, 1);
        var wallMaterial = new THREE.MeshLambertMaterial({color: 0x19FCBC, side: THREE.DoubleSide });
        var wall = new THREE.Mesh(wallGeometry, wallMaterial);
        scene.add(wall);
		
		wall.rotation.y = -0.5 * Math.PI;
		wall.position.set(60, 0, -120);
		
		var trigger00Geometry = new THREE.BoxGeometry(96, 96, 96, 6, 6, 6);
		var trigger00Material = new THREE.MeshLambertMaterial({color: 0xFF00FF, transparent: true, opacity: 0});
		var trigger00 =		new THREE.Mesh(trigger00Geometry, trigger00Material);
 
		scene.add(trigger00);
		collidableMeshList2.push(trigger00);
		trigger00.position.set(-120, 60, -120);
		
		var trigger02Geometry = new THREE.BoxGeometry( 40, 30, 4, 1, 1 );
		var trigger02Material = new THREE.MeshLambertMaterial({color: 0xFF00FF, transparent: true, opacity: 0});
		var trigger02 =		new THREE.Mesh(trigger02Geometry, trigger02Material);
		
		scene.add(trigger02);
		collidableMeshList3.push(trigger02);
		trigger02.position.set(120, 0, -135);
		
		var trigger03Geometry = new THREE.BoxGeometry( 6, 30, 4, 1, 1 );
		var trigger03Material = new THREE.MeshLambertMaterial({color: 0xFF00FF, transparent: true, opacity: 0.2});
		var trigger03 =		new THREE.Mesh(trigger03Geometry, trigger03Material);
		
		scene.add(trigger03);
		collidableMeshList.push(trigger03);
		trigger03.position.set(120, 0, -60);
	
		//SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)
	
		var greatSphereGeometry = new THREE.SphereGeometry(60, 24, 24, 0);
		var greatSphereMaterial = new THREE.MeshBasicMaterial({color: 0x0000FF, side: THREE.DoubleSide});
		var greatSphere 		= new THREE.Mesh(greatSphereGeometry, greatSphereMaterial);
		
		scene.add(greatSphere);
		
		greatSphere.position.set(120, 30, -120);
	
		var greatSphereGeometry = new THREE.SphereGeometry(60, 24, 24, 0);
		var greatSphereMaterial = new THREE.MeshBasicMaterial({color: 0x00000f, side: THREE.DoubleSide, wireframe: true});
		var greatSphere 		= new THREE.Mesh(greatSphereGeometry, greatSphereMaterial);
		
		scene.add(greatSphere);
		
		greatSphere.position.set(120, 30, -120);
	
		var mesh00Geometry 	= new THREE.BoxGeometry(120, 120, 120, 1, 1, 1);
		var mesh00Material 	= new THREE.MeshLambertMaterial({color: 0x19FCBC});
		mesh00			= new THREE.Mesh(mesh00Geometry, mesh00Material);
		scene.add(mesh00);
		//collidableMeshList.push(mesh00);
		mesh00.position.set(0, 0, 0);
		
		var mesh01Geometry 	= new THREE.SphereGeometry(90, 32, 32, 0, phiLength);
		var mesh01Material 	= new THREE.MeshBasicMaterial({wireframe: true, color: 0xFF0000});
		mesh01			= new THREE.Mesh(mesh01Geometry, mesh01Material);
		scene.add(mesh01);
		mesh01.position.set(-240, 30, -240);
				
		var mesh02Geometry 	= new THREE.BoxGeometry(120, 120, 120);
		var mesh02Material 	= new THREE.MeshLambertMaterial({color: 0x19FCBC});
		var mesh02			= new THREE.Mesh(mesh02Geometry, mesh02Material);
		scene.add(mesh02);
		mesh02.position.set(0, 0, -240);
		
		
		//** Wall2 = mesh03 **//
		var mesh03Geometry 	= new THREE.PlaneGeometry(240, 120, 1, 1);
		var mesh03Material 	= new THREE.MeshLambertMaterial({color: 0x19FCBC});
		var mesh03			= new THREE.Mesh(mesh03Geometry, mesh03Material);
		scene.add(mesh03);
		mesh03.position.set(180, 0, -180);
		mesh03.rotation.y = -.5 * Math.PI;
		
		var mesh04Geometry 	= new THREE.BoxGeometry(120, 120, 120);
		var mesh04Material 	= new THREE.MeshLambertMaterial({color: 0x19FCBC});
		var mesh04			= new THREE.Mesh(mesh04Geometry, mesh04Material);
		scene.add(mesh04);
		mesh04.position.set(240, 0, 0);
		
		var mesh05Geometry 	= new THREE.BoxGeometry(120, 120, 120);
		var mesh05Material 	= new THREE.MeshLambertMaterial({color: 0x000000});
		var mesh05			= new THREE.Mesh(mesh05Geometry, mesh05Material);
		scene.add(mesh05);
		mesh05.position.set(240, 0, 240);
		
		var mesh06Geometry 	= new THREE.BoxGeometry(120, 120, 120);
		var mesh06Material 	= new THREE.MeshLambertMaterial({color: 0x000000});
		var mesh06			= new THREE.Mesh(mesh06Geometry, mesh06Material);
		scene.add(mesh06);
		mesh06.position.set(0, 0, 240);
		
		var mesh07Geometry 	= new THREE.BoxGeometry(120, 120, 120);
		var mesh07Material 	= new THREE.MeshLambertMaterial({color: 0x00ff00});
		var mesh07			= new THREE.Mesh(mesh07Geometry, mesh07Material);
		scene.add(mesh07);
		mesh07.position.set(-240, 0, 240);
		
		var mesh08Geometry 	= new THREE.BoxGeometry(120, 120, 120);
		var mesh08Material 	= new THREE.MeshLambertMaterial({color: 0x0000ff});
		var mesh08			= new THREE.Mesh(mesh08Geometry, mesh08Material);
		scene.add(mesh08);
		mesh08.position.set(-240, 0,  0);
		
		var dotGeometry = new THREE.PlaneGeometry(.01, .01, 1, 1);
		var dotMaterial = new THREE.MeshLambertMaterial({color: 0x000000});
		var dot 		= new THREE.Mesh(dotGeometry, dotMaterial);
		dot.position.set(0,0,-2);
		camera.add(dot);
		
		var size = 240;
		var divisions = 10;

		var gridHelper = new THREE.GridHelper( 300, 100 );
		scene.add( gridHelper );
		
		axisHelper = new THREE.AxisHelper( 50 );
		scene.add( axisHelper );
		
		raycaster = new THREE.Raycaster();
		//raycaster.set( camera.getWorldPosition(), camera.getWorldDirection() );
        mouse = new THREE.Vector2();
        // add the output of the renderer to the html element
        document.getElementById("WebGL-output").appendChild(renderer.domElement);
		document.addEventListener('mousedown', onDocumentMouseDown, false);
        // call the render function
        //var step = 0;
		
		object01.push(mesh00);
		object02.push(mesh01);
		
		clock = new THREE.Clock();
		
		jsonLoader = new THREE.JSONLoader(loadingManager);
            jsonLoader.load('../assets/models/enveloppe.json',
                function(geometry, materials) {
                    enveloppe = new THREE.SkinnedMesh(geometry,
                        new THREE.MeshPhongMaterial({
                            normalScale: new THREE.Vector2(1, 2),
                            specular: 0x2A2926,
                            map: textureLoader.load('../assets/images/Enveloppe_Diffuse.jpg'),
                            normalMap: textureLoader.load('../assets/images/Enveloppe_NormalMap.jpg'),
                            specularMap: textureLoader.load('../assets/images/Enveloppe_SpecularMap.jpg'),
                            skinning: true
                        }));

                    enveloppe.geometry.computeVertexNormals();

                    mixer = new THREE.AnimationMixer(enveloppe);

                    action.idle = mixer.clipAction(geometry.animations[0]);
                    action.intro = mixer.clipAction(geometry.animations[1]);
                    action.ouverture = mixer.clipAction(geometry.animations[2]);

                    action.idle.setEffectiveWeight(1);
                    action.ouverture.setEffectiveWeight(1);

                    action.ouverture.setLoop(THREE.LoopOnce, 0);
                    action.ouverture.clampWhenFinished = true;

                    action.intro.setLoop(THREE.LoopOnce, 0);
                    action.intro.clampWhenFinished = true;

                    action.idle.enabled = true;
                    action.ouverture.enabled = true;

                    var position = {
						x: 120,
                        y: 30,
                        z: -160
                    };
                    enveloppe.position.x = position.x;
                    enveloppe.position.y = position.y;
                    enveloppe.position.z = position.z;
					
					
					//enveloppe.rotation.y = 2 * Math.PI;
					enveloppe.rotation.x = .2 - Math.PI;
					enveloppe.rotation.y = Math.PI;
					enveloppe.rotation.z = Math.PI;
					
					enveloppe.scale.set(4.5,4.5,4.5);
					
					scene.add(enveloppe);
					
					//action.idle.play();
                    //animate();
				});
				
				
				jsonLoader.load('../assets/models/feuille.json',
                function(geometry, materials) {
                    feuille = new THREE.SkinnedMesh(geometry,
                        new THREE.MeshPhongMaterial({
                            map: textureLoader.load('../assets/images/Feuille_Diffuse.jpg'),
                            normalMap: textureLoader.load('../assets/images/Feuille_NormalMap.jpg'),
                            normalScale: new THREE.Vector2(.75, .75),
                            specularMap: textureLoader.load('../assets/images/Feuille_SpecularMap.jpg'),
                            specular: 0x2A2926,
                            shininess: 3,
                            skinning: true
                        }));

                    feuille.geometry.computeVertexNormals();

                    mixer2 = new THREE.AnimationMixer(feuille);

                    action2.idle2 = mixer2.clipAction(geometry.animations[0]);
                    action2.intro2 = mixer2.clipAction(geometry.animations[1]);
                    action2.ouverture2 = mixer2.clipAction(geometry.animations[2]);

                    action2.idle2.setEffectiveWeight(1);
                    action2.ouverture2.setEffectiveWeight(1);

                    action2.ouverture2.setLoop(THREE.LoopOnce, 0);
                    action2.ouverture2.clampWhenFinished = true;

                    action2.intro2.setLoop(THREE.LoopOnce, 0);
                    action2.intro2.clampWhenFinished = true;

                    action2.idle2.enabled = true;
                    action2.ouverture2.enabled = true;


                    var position2 = {
                        x: 120,
                        y: 30,
                        z: -160
                    };

                    feuille.position.x = position2.x;
                    feuille.position.y = position2.y;
                    feuille.position.z = position2.z;
					
					feuille.rotation.x = .2 - Math.PI;
					feuille.rotation.y = Math.PI;
					feuille.rotation.z = Math.PI;
					
					feuille.scale.set(4.5,4.5,4.5);

					scene.add(feuille);
					
                    //animate();

                });

		//object03.push(enveloppe);
		
				var enveloppeCatcherGeometry = new THREE.PlaneGeometry(30, 20, 1, 1);
				var enveloppeCatcherMaterial = new THREE.MeshLambertMaterial({color: 0xFF0000, wireframe: true, transparent: true, opacity: 0 });
				var enveloppeCatcher = new THREE.Mesh(enveloppeCatcherGeometry, enveloppeCatcherMaterial);
				
				enveloppeCatcher.position.set(120, 15, -144);
				
				enveloppeCatcher.rotation.x = -Math.PI;
				enveloppeCatcher.rotation.z = Math.PI;
				enveloppeCatcher.rotation.y = Math.PI;
				scene.add(enveloppeCatcher);
				object03.push(enveloppeCatcher);
				
		var spotLight2 = new THREE.SpotLight(0xffffff, 1);
        spotLight2.position.set(120, 20, 0);
        spotLight2.castShadow = true;
		spotLight2.target.position.set(120,100,-120);
		//spotLight2.target = trigger03;
		scene.add(spotLight2.target);
        scene.add(spotLight2);
       //render();
    }
		
		function onDocumentMouseDown(event) { 
            //event.preventDefault();
            //mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            //mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera( new THREE.Vector2(), camera)
			
			var intersects = raycaster.intersectObjects(scene.children);
			
            var intersects01 = raycaster.intersectObjects(object01);

				if (intersects01.length > 0) {
						count01++;
						
						if(count01 % 2 == 0){
							rotation01 = true;
						}
						else{
							rotation01 = false;
						}
					}
			var intersects02 = raycaster.intersectObjects(object02);

				if (intersects02.length > 0) {              		
					count02++;
						
					if(count02 % 2 == 0){
						rotation02 = true;
					}
					else{
						rotation02 = false;
					}
				}
			
			//** Enveloppe trigger **//
			var intersects03 = raycaster.intersectObjects(object03);

				if (intersects03.length > 0) {              		
					count03++;
						
					if(count03 % 2 == 0){
					
						
					}
					else{
						rotation03 = false;
					}
				}		
			}
		
		function animate(){
		 setTimeout( function() {
			requestAnimationFrame( animate );
		}, 1000 / 60 );
			//requestAnimationFrame(animate);
			render();
		}
		var dt = 1/60;
			
        function render() {
			//velocity.x = 120;
		    var delta2 = clock.getDelta();
            mixer.update(delta2);
			mixer2.update(delta2);
			
			if(controls.enabled){
                    world.step(dt);
            }
			


			
	var originPoint = controls.getObject().position.clone();
	
	for (var vertexIndex = 0; vertexIndex < player.geometry.vertices.length; vertexIndex++){		
		var localVertex = player.geometry.vertices[vertexIndex].clone();
		var globalVertex = localVertex.applyMatrix4( player.matrix );
		var directionVector = globalVertex.sub( player.position );
		
		var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
		var collisionResults = ray.intersectObjects( collidableMeshList );
		var collisionResults2 = ray.intersectObjects( collidableMeshList2 );
		var collisionResults3 = ray.intersectObjects( collidableMeshList3 );
		
		if ( collisionResults3.length > 0 && collisionResults3[0].distance < directionVector.length() ) {
		
			action.idle.stop();
			action.ouverture.play();
			action2.idle2.stop();
			action2.ouverture2.play();
			sound.setVolume(0);
			stop = true;
			controls.getObject().position.set(120, 0, 0);	
		}
		
		if ( collisionResults2.length > 0 && collisionResults2[0].distance < directionVector.length() ) {
			mesh01.rotation.y += .05;	
		}
		
		if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) {
			
				//moveForward = false;
				//player.rotation.y += .01;
				
				
								
			push = true;
						
			controls.getObject().position.set(120, 0, -36);
			controlsEnabled = false;
			
			controls.getObject().rotation.set = .5 * Math.PI;
			controls.getObject().position.y += 2;
				
				
			mesh01.rotation.y += .001;
			action.idle.play();
			action2.idle2.play();
	
			play = true;
			audioLoader.load( '../assets/The_Monolith_On_The_Moon.ogg', function( buffer ) {
			sound.setBuffer( buffer );
			sound.setLoop(true);
			sound.setVolume(0.5);
			});
				sound.play();
				scene.remove(trigger03);	
				scene.remove(ambientLight);
			}
			
			if(push == true && stop == false){
				stop = false;
				controls.getObject().position.set(120, 0, -36);
				controls.getObject().position.z -= .018;
			}
			
				if ( controlsEnabled ) {
					raycaster.ray.origin.copy( controls.getObject().position );
					raycaster.ray.origin.y -= 10;
					
					var intersections = raycaster.intersectObjects( objects );
					
					var isOnObject = intersections.length > 0;
					
					//camera.position.x = -120;
					
					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;
					
					
					
					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;
					
					velocity.y -= 9.8 * 100.0 * delta // 100.0 = mass
					
					if ( moveForward ) velocity.z -= 400.0 * delta;
					if ( moveBackward ) velocity.z += 400.0 * delta;
					
					if ( moveLeft ) velocity.x -= 400.0 * delta;
					if ( moveRight ) velocity.x += 400.0 * delta;
					
					/*if ( isOnObject === true ) {
						velocity.y = Math.max( 0, velocity.y );
						
						//canJump = true;
					} */
					
					controls.getObject().translateX( velocity.x * delta );
					controls.getObject().translateY( velocity.y * delta );
					controls.getObject().translateZ( velocity.z * delta );
					
					
					if ( controls.getObject().position.y < 10 ) {
						velocity.y = 0;
						controls.getObject().position.y = 10;
					
						
						//canJump = true;
					}
					
					prevTime = time;
				}
		phiLength = 1.6;
		
		for(var i = 1; i < 3; i++){
				phiLength += .01;
			}
			
			if(rotation01 == true){
				mesh00.rotation.y += .001;
				//player.rotation.y += .01;	
			}			
			if(rotation02 == true){
				mesh01.rotation.y += .01;
			}

			//console.log(camera.position);
            // render using requestAnimationFrame
            renderer.render(scene, camera);
		
			//stats.update();
        }
		}
	
	console.log(scene.children);
	
</script>
</body>
</html>
